{"posts":[{"title":"Yorg.io 进阶指南","content":"Yorg.io 进阶指南 目录 [TOC] 开始 在你阅读这篇指南的时候，我假定你已经活过了第50天，Level10+。现有水晶在1千万以上。 第一步 存档，保存一下你现在的进度。 第二步 拆除你的所有设施。 可能你觉得很荒唐，但是就是这样的。拆除并重新建造是成神的第一步。 第三步 重新安排你的水晶矿机，围绕着主基地排列。 存档 第四步 重新安排其他矿机，让他们围绕着水晶矿机排列。 我们把这个区域叫做一个矿区。 存档 第五步 用运输线连接矿机 如果你已经解锁了空间翘曲技术，请直接前往第七步 第六步 将各种工厂安置在运输线上。 第七步 在每个矿区周围安置以下数量的武器： 名称 数量 加农大炮 弓箭塔 弓箭塔 8 闪电塔 4 以后的步骤将会分成x.A x.B两种，请遵循其中的一种进行后面的更新。 第八.A步 定位到地图的边缘，按住字母E的同时按住ASDW控制方向，绘制出连续的城墙。 第八.B步 在每个矿区周围搭建围墙 第九.A步 在城墙上开个口，然后如下图所示搭建城墙 （黑色的是地图边界，灰色的是城墙，红色的⭕是主基地） 第十.A步 在这个通道周围布满武器塔 第十一步 开始游戏 最终效果 存档下载 你真的要这样吗？链接 ","link":"https://hesy-zhoulijie.github.io/post/yorgio/"},{"title":"国外浏览器评测","content":"国外浏览器评测 [toc] 链接汇总 大目录：https://o8.cn/5gIlMZ chrome_85.0.4183.102.exe：https://www.90pan.com/b2107538 密码：2fv5 Firefox80.0.1.exe：https://www.90pan.com/b2107539 密码：qum4 MicrosoftEdge85.0.564.51X86.msi：https://www.90pan.com/b2107540 密码：a641 chromium.zip：https://www.90pan.com/b2107556 密码：ocy3 Safari.zip：https://www.90pan.com/b2107561 密码：dgcd Opera72.0.3798.0dev.zip：https://www.90pan.com/b2107581 密码：no96 谷歌浏览器(Google Chrome) 【下载地址】 chrome_85.0.4183.102.exe：https://o8.cn/iKaCSK 密码：2fv5 谷歌浏览器Google Chrome是由Google公司开发的一款设计简单、高效的Web浏览工具，目前浏览器市场占有率绝对第一，谷歌浏览器带给用户高速、稳定、安全的网络浏览体验。 该浏览器是基于其他开放原始码软件所撰写，包括WebKit和Mozilla，目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。Google Chrome支持多标签浏览，每个标签页面都在独立的“沙箱”内运行，在提高安全性的同时，一个标签页面的崩溃也不会导致其他标签页面被关闭。 chrome浏览器相比其他浏览器胜在速度上，简洁快速，用了chrome再也看不上别的浏览器了。专业人士爱用chrome，不过占用内存有点大。chrome现在浏览器市场占有率超过60%基本是所向披靡。总结下chrome为什么会是主流的原因： 1.同步：基于谷歌账号的多端同步。能够满足对书签，浏览记录同步，等等有很强的需求。 2.chrome安全性好：沙盒设计，异步进程架构，再加上Google Safe Browsing，下载前检测机制等等。 3.快：还是那句话，用过快的，就不喜欢慢的。 4.chrome扩展多：各种实用的扩展，相比firefox的扩展，对浏览器本身影响更小，热更新。其中有些是上网必备的。如果chrome web store连不上，可以去国内的一些商店安装，还可以下载下来离线安装，还可以直接安装自定义的脚本，这些小工具有时候是非常管用的。 5.简洁：现在浏览器的 UI 都互相借鉴（或者说抄袭），我也不知道 Chrome 的 UI 是否原创，不过简洁的界面的确是一大优势，特别是最新的 Chromium，甚至隐藏了地址栏。 当然缺点也有，比如网银，很多都不支持Chrome，还有就是吃内存呀，另外就是链接内文字的复制也是一大缺点。 特色 1、速度 谷歌浏览器(Google Chrome) 浏览器追求的是全方位的高速体验，它可以快速地从桌面上启动，并能迅速加载网页，而在运行复杂的网络应用时更是迅雷不及掩耳。 2、简约 谷歌浏览器(Google Chrome) 浏览器的窗口采用了清爽简洁的流线型设计。例如，您可以通过同一个框执行搜索和导航操作，还可以轻松快捷地随意排列标签页。 3、安全性 谷歌浏览器(Google Chrome) 浏览器通过以下功能为您提供更加安全的上网体验：内置的恶意软件和网上诱骗防护功能、自动更新（可确保您获得所有最新的安全修补程序）等。 4、隐私设置 谷歌浏览器(Google Chrome) 能够让您控制自己的隐私信息，同时还能帮助保护您在网上共享的信息。 5、自定义 ​ 您可以通过各种各样的方法来自定义 谷歌浏览器(Google Chrome) 浏览器，从而享受独一无二的体验。无论是更改设置，还是从 谷歌浏览器(Google Chrome) 网上应用店添加应用、扩展程序和主题背景都轻而易举。 6、登录 ​ 登录谷歌浏览器(Google Chrome) 浏览器可让您在自己的所有上网设备上使用相同的书签、历史记录以及其他设置。这样还可以让您自动登录所有喜爱的 Google 服务。 使用技巧 一. 快速关闭标签页 相信大多数人依旧是用鼠标直接点击那个关闭按钮来进行标签关闭的，你或许知道 Chrome 专门对标签关闭优化过，每次点击关闭后会自动改变标签宽度，这样可以通过在同一位置连续点击鼠标来快速关闭多个标签页，因此相对其他浏览器用鼠标点击关闭效率其实还算不低。不过这个优秀的细节面对固定标签就不行了，此外老是通过鼠标点击关闭的话对于一个极客来说也太显得图样图森破了，今天极客公园为你推荐另外两种快速关闭标签页的方法：1.在要关闭标签页下按下 Ctrl/ + W 组合快捷键 （适用于任何标签页关闭）2.在要关闭标签页下中键单击（按下滚轮） （关闭标签最简单最快捷方法）除了 Ctrl/ + W 快捷键关闭标签页外，你还应该记住 Ctrl/ + T 快速打开新标签页，Ctrl/+Shift+T 重新打开最新关闭的标签，Ctrl/+Shift+V 将剪切板中的内容无格式粘贴等快捷键组合，更多请查看官方指南。 二. 设备间同步标签页 随着智能移动设备在生活中占据的地位越来越重，能够打通桌面与移动端的数据，统一体验将会越来越受用户欢迎。在这方面 Chrome 暂时做得还不错，近两年 Google相继推出官方的Chrome Andriod 版本（需4.0以上）和Chrome iOS 版本（需4.3以上）。通过“同步书签、同步密码、发送到移动设备、自动登录、智能建议”这些功能可以将在桌面电脑上打开的标签页、存储的书签和多功能框数据同步到您的手机或平板电脑上。下面以不同设备间标签页的同步为例为你介绍 Chrome 的同步功能。同步标签页需要相应设备对应版本，确保“打开的标签页”复选框处于选中状态当桌面版和移动版 Chrome 都已经登录同一账户并处于联网状态时就可以在新标签页（按下 Ctrl/⌘ +T ）下右下角的&quot;其他设备&quot;中查看，点击即可在当前设备上打开同步的标签页。打开的标签页是按设备进行分组的，要管理（隐藏、重命名、删除）特定设备的话，可以到云打印页面设置。 三. 发送标签页到移动设备 除了不同设备间书签、标签等数据同步外，Chrome 还可以一键将当前浏览的标签页直接发送到关联在同一账户下的移动设备上。如果你安装的为 Chrome Dev 版本并且关联了其他设备下的 Chrome 版本的话你会发现在地址栏右侧会出现一个手机的图标，点击它就可以将当前网页一键发送至移动设备上去。（其他版本暂需安装官方Chrome to Mobile插件 四. Tab 智能搜索 你可能知道在 Chrome 浏览器中直接在地址栏中就可以搜索，也可能知道直接选中文本然后右键选择在 Google 搜索或复制然后在地址栏中粘贴并搜索，但你或许不知道 Tab 搜索。那么什么是 Tab 搜索呢？ 如果 Chrome 已记录该网站的搜索引擎（即你在某个网站内使用过其搜索框），按下 Tab 键 Chrome 会自动选择该搜索引擎进行关键字搜索，即可以直接在地址栏内对特定的网站进行搜索。（与 Windows 8 内置的应用内搜索有点类似）以后再也不用先打开豆瓣，再点击豆瓣电影然后再在搜索框内进行搜索了…… 五. Chrome 拖动技巧 在 Chrome 中除了可以拖动上传以及拖动下载文件外，你或许还知道拖动标签（左右改变位置、里外分离拖拽回窗口），其实对于网页里的内容也是可以拖动的。1.拖动搜索 （地址栏、标签栏）2.拖动图片 （地址栏、标签栏）3.拖动链接 （地址栏、标签栏、书签栏）4.拖动本地 HTML、图片、pdf文件（地址栏、标签栏、书签栏）对应元素拖动到地址栏上将会在当前窗口搜索/打开该元素内容，如果拖动到标签栏上则新建窗口搜索/打开。 六. 使用语音识别搜索 如果在 Chrome 浏览器中看到文本框带有麦克风图标的话就表示，那就表示可以通过语音输入，而不用键盘输入内容了。直接点击麦克风图标或将光标放到文本框中然后按Ctrl/⌘ + Shift + .（英文句号）组合键即可。语音搜索这一点对于输入不便的移动设备来说更是尤为重要，这也是为什么语音搜索服务最早登录移动平台（m.google.com），移动版 Chrome 在地址栏默认就有语音搜索功。 七. Chrome Experiments Google 有一个叫做Chrome Experiments的网站，在这个网站里除了可以浏览各种以 JavaScript、HTML5 和 WebGL 编写的创新实验展示，如有趣好玩的游戏（Cube 3D地图）、互动电影，新颖惊艳的Impress.js（内容展示效果库，类似3D 版 PPT） 、Kinect+WebGL、其他各种有用的库等。此外今年还新增了专门面向移动设备的页面。 Firefox(火狐浏览器) 【下载地址】 Firefox80.0.1.exe：https://o8.cn/1GfS2X 密码：qum4 Mozilla Firefox是一个自由的，开放源码的浏览器，火狐浏览器适用于Windows,Linux和MacOSX平台。火狐浏览器还有其它一些高级特征，如标签式浏览，可以禁止弹出式窗口。 Mozilla Firefox，中文名通常称为“火狐”或“火狐浏览器”。是一个自由的，开放源码的浏览器，适用于Windows, Linux 和 MacOS X平台。引擎反应更快，内存占用更少，速度更快，真正的隐私保护，还有众多自定义功能。 功能介绍 选择外观: 主题 打造符合你风格的火狐浏览器（Firefox）。您可以从几万个出自全世界不同国家设计师设计的火狐浏览器（Firefox）皮肤主题 中挑选适合您的主题，也可以自己动手 制作主题。只需简单的一个点击，即刻换上您想要的火狐浏览器（Firefox）主题皮肤。 自定义：附加组件 火狐浏览器（Firefox）拥有超过一万个的 扩展（add-ons），提供各种不同的扩展功能，您可以简单的下载、安装这些扩展以增强您的火狐功能，帮助您更好、更个性化的体验网上冲浪。无论是在网上听音乐，看视频，购物，看新闻...都能找到相应的火狐浏览器（Firefox）扩展能帮助您提升体验，这里 是一些我们推荐给您的扩展精选。 插件更新检查 插件是由类似 Adobe Systems 或者 Apple 这些公司制作的第三方软件，用来播放视频、实现动画或者制作游戏（例如 Flash Player 或者 Quicktime）。它们可能导致浏览器的崩溃或者在一段时间后被发现安全漏洞，所以火狐浏览器（Firefox）开发了一个简单的工具来确保您使用的插件是新版。 自定义您的界面 新版火狐浏览器（Firefox）中，彻底重新设计了自定义浏览器界面的交互体验，操作更简单方便。 在新版火狐浏览器（Firefox）的界面上，移除了底部的附加组件栏，同时火狐浏览器（Firefox）为您提供了一个全新的菜单面板，可以快速方便的在这里找到所有您需要的功能。点击火狐浏览器（Firefox）菜单面板下方的&quot;自定制&quot;，您将进入到自定义面板，在这里您可以通过直接拖拽按钮，自由的添加、移动、删除您要调整的按钮。确保那些您常用的功能（附加组件、隐私浏览、同步等等）一键即可进入。 火狐浏览器和谷歌浏览器的对比： 在安全性方面： 谷歌浏览器会定期的下载更新两组黑名单（分别是防止网络钓鱼和恶意软件），并会在使用者试图浏览可能造成电脑损害的网站时予以警告。 火狐浏览器（Firefox）自身有阻止弹出性窗口的功能，并且在安装火狐时自定义模式下可以安装一款扩展提高安全性能。 在速度方面： 谷歌浏览器使用谷歌自身研发的Chrome内核当你双击谷歌浏览器标志时，几乎立刻就能启动浏览器，这点是同类产品做不到的一点，同时在用谷歌浏览器浏览网页时几乎感觉不到是通过浏览器在浏览，给用户以全新流畅的体验。 火狐浏览器使用Gecko内核，具有上网速度快，整体轻便，界面简洁等特征。火狐浏览器（Firefox）浏览网页时采用的分页浏览的方式，可以加快页面加载的速度，这也是其成为好用的网页浏览器的重要原因之一。 在功能方面： 火狐浏览器自由度高，用户能够在浏览器上安装多种插件，方便用户使用站点的特殊功能。但由于开发者大部分使用谷歌浏览器，所以某些网站或内容在火狐浏览器不能完美呈现。 谷歌浏览器也有浏览器插件的功能，但由于谷歌插件商店经常处于打不开的状态，所以插件安装文件需要通过其他途径进行下载。 在稳定性方面： Chrome大的亮点就是多进程架构，保护浏览器不会因恶意网页和应用软件而崩溃。通过将每个站点或应用程序封闭起来提高系统安全性。但谷歌浏览器的最大弊端是占用内存较大，特别是同时打开多个页面的情况下尤为明显，但同时也具有高性能的表现，所以更适合高内存计算机用户使用。而火狐浏览器的兼容性较强，牺牲了部分速度保证整体使用的稳定性。 Microsoft Edge浏览器 【下载地址】 MicrosoftEdge85.0.564.51X86.msi：https://o8.cn/VoGrVO 密码：a641 【内测版本】 https://www.microsoftedgeinsider.com/zh-cn/ 最新的dev版本有彩蛋 微软已正式公布采用Chromium内核的全新Edge浏览器，Microsoft Edge浏览器在新版Windows 10上已经支持，交互界面更加简洁，还将兼容现有Chrome与Firefox两大浏览器的扩展程序。用户安装的插件将与Chrome与Firefox类似，显示在工具栏上。 全新的Edge浏览器支持同步书签、密码、历史记录和标签，实现类似于Firefox Sync的功能。 软件特色 IE 模式 在新版的Edge中，可以一键切换为IE11内核，借助此功能你可以正常访问一些老旧的网站，例如部分学校和政府机构的网站 跟踪防护 将会更加注重用户的安全隐私控制 快速收藏 Edge可以和office套件便捷交互，导入导出分享将会变得更加轻松 新版Edge支持的平台非常多，除了 windows 还支持 macOS，当然Edge也有移动端的，Android和IOS版本均可和桌面版同步 设置中文语言方法 点击右栏的菜单-Settings-languages 点击Add languages 这里我们可以通过搜索找到中文，推荐大家添加简体中文，这里因为我添加过了，所以没显示 依次勾选，应用语言到整个Edge浏览器 再点击Restart重启浏览器 这样可以看到浏览器就是中文界面了 Chromium浏览器 【下载地址】 chromium.zip：https://o8.cn/IY27Rh 密码：ocy3 Chromium浏览器是一款基于Google Chrome浏览器的开源版，Chromium浏览器相比Chrome具有更加丰富的功能更新颖的功能给专业人员使用，Chromium浏览器的核心思想就是简单、高速、稳定、安全的浏览网页。 基本简介 Chromium是一个由Google主导开发的网页浏览器。以BSD许可证等多重自由版权发行并开放源代码。Chromium设计思想基于简单、高速、稳定、安全等理念，在架构上使用了Apple发展出来的WebKit排版引擎、Safari的部份源代码与Firefox的成果，并采用Google独家开发出的V8引擎以提升解译JavaScript的效率，而且设计了“沙盒”、“黑名单”、“无痕浏览”等功能来实现稳定与安全的网页浏览环境。Chromium是Google为发展自家的浏览器Google Chrome（以下简称Chrome）而开启的计划，所以Chromium相当于Chrome的工程版或称实验版（尽管Chrome自身也有β版阶段），新功能会率先在Chromium上实现，待验证后才会应用在Chrome上，故Chrome的功能会相对落后但较稳定。Chromium和Chrome所使用的webkit内核是目前公认的最快的网页浏览方式。 软件特色 - Chromium浏览器基于开源引擎WebKit、Blink，其中包含谷歌Gears。 - Chromium提供了浏览器扩展框架，可以制作与Adobe-AIR类似的混合应用。 - 包含V8 Javascript虚拟机，这个多线程的虚拟机可以加速Javascript的执行。 - 具备隐私浏览模式，可以让用户无需在本地机器上登录即可使用，这个功能与微软IE8中的Incognito类似。 - 浏览器将内置防止“网络钓鱼“及恶意软件功能。 功能介绍 - Chromium浏览器使用了额外的Loader使配置文件与程序文件存放于同一个文件夹，适合U盘携带，或者经常重装的人群。 - 能通过“设置默认浏览器。EXE”将浏览器设置为默认浏览器。并且设置之后在任何地方调用浏览器都不会出现丢失设置的情况。并且能创建桌面以及程序菜单快捷方式。不过设置默认浏览器之后，程序所在文件夹不能改名或者删除; - 优化了浏览器配置。附加了一些常用的浏览器插件。其中有一些插件默认是停用的，如果需要的话，随时启用即可。 - 能通过一个批处理文件“清除所有个人信息与自定义设置。bat”快速的将所有此浏览器的浏览记录以及个人信息删除。以便重新定制并分发给其他用户。 Loader使用c语言编写。尽量减少垃圾文件产生以及资源占用。 常见问题 问：chrome与chromium有什么区别？ 1、安装模式 Chromium可以免安装，下载zip压缩包后解压缩即可使用，而Chrome虽然理论上也可以免安装，但Google仅提供安装版。 2、程序图标 两者图标只在色彩上有不同，Chromium的是天蓝色系，而Chrome的则是Google公司的代表色（红、黄、蓝、绿）。 3、新功能会率先在Chromium上推出，Chrome则会相对落后许多。 问：浏览器支持多用户登录吗？ 在实验室里打开Multiple profiles项目，在重启浏览器之后，即可看到窗口右上角显示当前登录的帐户名称。点击该名称，点击Create a new profile手动接创建一个新的帐户，这会让你再新打开一个使用不同帐户的窗口，你不仅可以用不同马甲帐户和cookies登录网站，还有完全不同的Chrome扩展、主题、网页应用、收藏夹、设置参数等等。 问：缺少Google API密钥,chromium的部分功能无法使用怎么解决？ 1、在使用chrome浏览器便携版-chrome的时候，会出现以下问题： 2、缺少google api密钥,因此chromium的部分功能将无法使用 3、这时候，谷歌账户无法登陆，十分不便。 Safari浏览器 【下载地址】 Safari.zip：https://o8.cn/kigrgU 密码：dgcd Safari是目前在windows平台上速度最快的浏览器，业界标准iBech测试显示，Safari浏览网页速度是IE 7的两倍，Firefox 2的1.6倍 Safari浏览器是苹果Mac OS X平台的多标签的网络浏览器。苹果电脑发布了Windows版本的Safari，它支持Windows XP和Windows Vista操作系统，目前Safari 5正式版已经发布。多国语言版，自适应简体中文界面。Safari5完美支持HTML5，还包括大量全新改进。 速度不错但是兼容性不佳，用Safari 点下载链接是不会打开迅雷的，同时qq秀也不支持，许多东西要装插件。不过界面很漂亮很智能，用的舒服。 顺便提示一下Safari 用迅雷的方法 ：先打开迅雷 ，在safari里找到要下载的东西之后选中链接右键复制，迅雷会自己跳出来 软件特色 Safari 是第一个支持 HTML5 音频和视频标签的浏览器。开发者可以将媒体文件直接整合到标准网页中，大大节约了开发时间，提高了响应速度。 对 HTML5 视频的全屏和隐藏字幕支持让开发者提供了更丰富、更易于获得的视频观看体验。 有了地理定位支持，选择了共享位置信息的用户可定制个性化网站内容。 Safari 还支持 HTML5 离线科技，基于网站的应用程序可以将信息存在本地硬盘中，无需网络连接也可随时使用。 苹果浏览器功能特点介绍： 多线程架构，让每一个网页都在独立线程中运行，互不影响，速度更快。 内置播放器，自动匹配歌词，显示音乐频谱，给歌曲评分，设置智能播放列表。 实时更新的黑白名单功能，阻止尽可能多的非法网站，为您的网络冲浪护航。 苹果浏览器是目前占用内存最低的软件之一，使得浏览网页运行更快。 苹果浏览器是一款集网络浏览和网络搜索于一体，使用户在冲浪更方便。 发展趋势 苹果Safari浏览器增长速度比微软Edge快 在浏览器市场，苹果和微软从来都不是直接竞争对手，毕竟每一家自己的浏览器方案都仅限于特定的平台或设备。其中，苹果的 Safari 主要针对 macOS 平台，其 Windows 版本在 2012 年就停止更新了。而微软现在全新的 Edge，如今只能在 Windows 10 上使用，并无针对其他平台的计划。 不过，现在有一个有趣的事实是，尽管微软 Windows 10 系统本身增长速度比 macOS 快得多，但实际上苹果的 Safari 浏览器增长速度比微软 Edge 还要快。 根据市场调研提供的统计数据了解，2017 年 5 月份，微软 Edge 浏览器仅提高了 0.01% 的市场份额，从 5.62% 增长到 5.63%。对比之下，苹果的 Safari 浏览器获得了 0.12% 的市场份额增长，在一个月时间内从 3.44% 增长到了 3.56%。 当然了，无论是微软 Edge 还是苹果 Safari，其实都是五十步笑百步，毕竟两者只占据了整个市场很小的市场份额。目前在整个浏览器市场上，最大魔头当属谷歌Chrome浏览器，目前在桌面平台上所占据的市场份额高达 59.36%。这意味着，无论是苹果 Mac 还是微软 Windows 平台，平均每 10 台电脑中就有高达 6 台安装了 Chrome 浏览器。 至于其他浏览器平台，Internet Explorer 的市场占有率仅剩下 17.55%，而 Mozilla Firefox 则为 11.98％ 的市场份额。 Opera浏览器 【下载地址】 Opera72.0.3798.0dev.zip：https://o8.cn/qXaOgH 密码：no96 Opera浏览器绿色便携版是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，作为一款主流桌面浏览器，Opera浏览器以它的快速、小巧和比其他浏览器更佳的标准兼容性在网上受到很多人的推崇。 Opera支持多种操作系统，如Windows、Linux、Mac、FreeBSD、Solaris、BeOS、OS/2、QNX等，此外，Opera还有手机用的版本，在2006年更与Nintendo签下合约，提供NDS及Wii游 乐器Opera浏览器软件；也支持多语言，包括简体中文和繁体中文。 Opera还提供很多方便的特性，包括Wand密码管理、会话管理、鼠标手势、键盘快捷键、内置搜索引擎、智能弹出式广告拦截、网址的过滤、浏览器识别伪装和超过400种,可以方便下载更换的皮肤，界面也可以在定制模式下通过拖放随意更改。下载一个大约10M的扩展以后，它甚至可以让你用语音控制以及阅读网页（英文）。而以上的这些，包括右键菜单都是可以由用户自定义的。 Opera浏览器绿色便携版是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，作为一款主流桌面浏览器，Opera浏览器以它的快速、小巧和比其他浏览器更佳的标准兼容性在网上受到很多人的推崇。 功能介绍 更方便的同步功能 只需登录您的 Opera 帐户，同步浏览数据 - 书签、打开的标签、密码和输入的历史记录。 更快的运行速度 Opera Turbo 会压缩页面数据，实现更加快速地浏览。 更具个性的浏览器 Opera 浏览器拥有 1,000 多个扩展，您可以轻松进行自定义。 更简单的风格 Opera 浏览器具有合并的搜索和地址栏功能，更能够自定义键盘快捷键和鼠标手势。 更安全、更隐私的浏览保护 Opera 能够保护您的浏览安全，您尽可专心浏览。 提高效率 最近关闭的标签、标签循环功能，以及其他小改进都能替您节省上网时间。 获取最新新闻 凭借 Opera 焕然一新的新闻功能，您可以从浏览器首页直接以您的语言获取最新文章。 这里我偷懒了，直接引用了PC6的链接。 Vivaldi浏览器 Anaheim浏览器 Seamonkey浏览器 Lunascape(三核心浏览器) Yandex浏览器 Microsoft Edge Dev(Chromium Edge开发版) Opera developer IceCat(冰猫浏览器) slashB(web开发浏览器) Whale浏览器 Opera GX 科摩多安全浏览器(Comodo Dragon) Chrome懒人版 Midori for Windows(轻量级浏览器) Deepnet Explorer ","link":"https://hesy-zhoulijie.github.io/post/intlbrowser/"},{"title":"C++ 编译优化","content":"很多人说O2很快，真的吗？ 话不多说，先贴图： 环境： WSL Ubuntu 18.04LTS sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ g++ file.cpp -o file.out sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ vi ./file.cpp sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ time ./file.out real 0m0.063s user 0m0.047s sys 0m0.016s sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ g++ file.cpp -o file.out -O2 sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ time ./file.out real 0m0.013s user 0m0.000s sys 0m0.000s sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ g++ file.cpp -o file.out -O3 sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ time ./file.out real 0m0.016s user 0m0.016s sys 0m0.000s sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ g++ file.cpp -o file.out -Ofast sweepy@DESKTOP-M79ULPC:/mnt/c/Users/zljzl/desktop$ time ./file.out real 0m0.012s user 0m0.000s sys 0m0.016s 源代码是这样的（计算1~10000000的平方和） #include&lt;iostream&gt; using namespace std; int main(){ int ans=0; for(int i=0;i&lt;10000000;i++){ ans+=i*i; } return 0; } 总而言之，O(fast)O(fast)O(fast)真的很快 ","link":"https://hesy-zhoulijie.github.io/post/o2/"},{"title":"你还在用辣么贵的的Microsoft Word？来看看这些免费的替代品吧。","content":"你还在用辣么贵的的Microsoft Word？ 来看看这些免费的替代品吧。 目录 [toc] Libre Office - Writer LibreOffice是OpenOffice.org办公套件衍生版， 同样自由开源，以Mozilla Public License V2.0许可证分发源代码，但相比OpenOffice增加了很多特色功能。LibreOffice拥有强大的数据导入和导出功能，能直接导入PDF文档、微软Works、LotusWord，支持主要的OpenXML格式。软件本身并不局限于Debian和Ubuntu平台，现已持Windows、Mac和其它Linux发行版等多个系统平台。 支持文件格式 文本文档： *.odm, *.sgl, *.odt,*.ott, *.sxw, *.stw, *.fodt, *.xml, *.docx,*.docm, *.dotx, *.dotm, *.doc, *.dot, *.wps, *.pdb, *.hwp, *.html, *.htm, *.lwp, *.psw, *.rft, *.sdw, *.vor, *.txt, *.wpd ,*.oth. 评价 总的来说，LibreOffice的界面没有微软Office那么华丽，但非常简单实用。它的六大组件对应Office丝毫不差，而且对系统配置要求较低，占用资源很少。支持众多扩展插件，可增加许多实用功能；一个很好的特性就是LibreOffice可以随身携带。您可以将它安装在你的优盘或便携式硬盘里，甚至是一个SD卡，随便你把它放在哪儿都可以。 分数 ⋆ ⋆ ⋆ ⋆ ⋆\\star\\ \\star\\ \\star\\ \\star\\ \\star⋆ ⋆ ⋆ ⋆ ⋆ Google Docs 因为众所周知的原因，这里就不写了 WPS Office WPS Office是由金山软件股份有限公司自主研发的一款办公软件套装，可以实现办公软件最常用的文字、表格、演示，PDF阅读等多种功能。具有内存占用低、运行速度快、云功能多、强大插件平台支持、免费提供海量在线存储空间及文档模板的优点。 支持阅读和输出PDF（.pdf）文件、具有全面兼容微软Office97-2010格式（doc/docx/xls/xlsx/ppt/pptx等）独特优势。覆盖Windows、Linux、Android、iOS等多个平台。WPS Office支持桌面和移动办公。且WPS移动版通过Google Play平台，已覆盖超50多个国家和地区。 支持文件格式 .doc.docx.dot.dotx.wps.wpt等文件格式的打开，包括加密文档； 评价 WPS Office个人版对个人用户永久免费，包含WPS文字、WPS表格、WPS演示三大功能模块，另外有PDF阅读功能。与Microsoft Office中的Word，Excel，PowerPoint一一对应，应用XML数据交换技术，无障碍兼容docx.xlsx.pptx，pdf等文件格式，你可以直接保存和打开 Microsoft Word、Excel和 PowerPoint 文件，也可以用 Microsoft Office轻松编辑WPS系列文档。 1、云文档，云服务 团队：WPS云文档支持团队创建，可以按照班级与自定义创建团队，方便课件、作业、资料的存储、共享、管理以及成员操作权限控制 协作：支持表格、文字、演示组件的多人多端实时协作，便捷进行文件的分发、流转、回收、统计与汇总 安全：支持云端备份、文档加密、历史版本追溯，安全创作云文档 2、智能AI工具 PDF转换工具集：支持PDF与Word、Excel、PPT之间的格式互转，支持各种格式文档输出为图片 OCR：文字识别技术抓取文档内容并整理形成新文档 PPT：一键美化，自动识别文档结构，快速匹配模板。 文档翻译：支持多国语言划词取词 智能校对：通过大数据智能识别和更正文章中的字词错误 3、校园工具 论文查重：多平台选择，计算重复率，定位到重复段落，提供参考性替换内容 简历助手：多平台选择简历模板库，一次填写，一键投递 答辩助手：答辩框架与模板 会议功能：远程课堂演示支持多人多端多屏同步播放，随时随地学习、讨论、分享 手机遥控：手机智能控制演讲 演讲实录：记录课堂讲演的每一分钟，课程整理、分享与传播 4、绘图工具 思维导图：多种结构、多样板式 几何图、LaTeX公式图：满足学科电脑制图需求 5、全面兼容，支持PDF 全面兼容Office格式，新增PDF组建支持 6、素材库和知识库 素材库：模板、字体、动画、图表、图片、图标......资源持续更新 知识库：考试辅导、个人提升、职场技能、商业管理.....名师课程持续更新 分数 ⋆ ⋆ ⋆ ⋆\\star\\ \\star\\ \\star\\ \\star⋆ ⋆ ⋆ ⋆（广告太多，扣一分） 永中Office 江苏永中软件股份有限公司旗下的一款办公软件，永中office在一套标准的用户界面下集成了文字处理、电子表格和简报制作三大应用；基于创新的数据对象储藏库专利技术，有效解决了Office各应用之间的数据集成共享问题。永中Office可以在Windows、Linux等多个不同操作系统上运行。历经多个主要版本的演进，永中Office的产品功能丰富，稳定可靠，可高度替代进口的同类软件，且具备诸多创新功能，是一款自主创新的优秀国产办公软件。 支持文件格式 pdf、doc、docx、xls、xlsx、ppt、pptx、uof、eio、html、txt、... 评价 永中Office开创性地将三大应用集成于一体，并通过创新的数据对象储藏库专利技术，有效解决了Office各应用之间的数据集成、应用集成、文档集成等问题，构成了一套独具特色的集成办公解决方案，引领新一代办公革命。 应用集成 开创性地将三大应用集成在一个界面之中，统一的交互方式更便于用户的使用。应用集成同时也成为各应用间的数据集成的基础。 数据集成 三大应用中的数据建立链接关系后，互相引用，同步更新，使数据管理和维护工作变的得心应手。 文件集成 多个文字处理、电子表格、简报制作文档可集成于一个集成文件中。产品特有的数据对象储藏库技术支持在电子表格中存放文字处理、简报制作应用，及其他多种数据对象，对文档及数据管理工作带来了极大的便利。 跨平台 支持在Windows、Linux和Mac OS等操作系统上运行，并确保用户一致的使用体验。永中Office进一步扩展了系统平台，可在WindowsVista操作系统中直接安装和运行。同时支持在最新MID设备及U盘上直接运行，给用户带来全新的移动办公体验。 精确兼容 该产品可双向精确兼容微软Office97、2000、2003各版本的文档，同时支持微软最新的Office版本2007。可打开和保存doc、xls和ppt文件；微软Office模板文件（dot、xlt和pot文件），并可打开微软Office产生的碎片文件及加密的微软Office文档。 三大应用均可存取纯文本TXT格式，也支持带编码的TXT文件并可进行编码转换；文字处理应用支持存取丰富文本格式；电子表格可打开DBF、DB等数据库文件，支持存取CSV文件，文字处理和简报制作文档可保存为一组图片。 国家标准 标文通是由国家电子政务总体组所属的中文办公软件基础标准工作组组织制定的《中文办公软件文档格式规范》国家标准（简称标文通即UOF）是我国拥有自主知识产权的文档格式标准，该标准将为我国建立自主可控的信息产业发挥重要作用。永中Office 2010全面兼容标文通，开启中国标文通标准新纪元！ 标文通标准的制定，使得国产办公软件厂商能够有效掌握国内市场竞争的主动权，获得更大的生存空间。标文通标准是一个开放的、基于XML的标准，使用标文通文档格式进行信息交换，用户可以真正掌握文档信息的控制权。 永中Office 2010基于自主开发环境，采用源代码级底层支持，具有存取速度快、内容完整、标准符合性高等特点，使得永中Office成为支持标文通文档标准的最佳Office产品。 中文特色 永中Office具有符合国人使用习惯的特性，提供极其丰富的中文特色功能：文本竖排、稿纸信笺、自加注拼音、简繁体转换、中文项目编号、中文信封模板、中文斜线表格、信封打印工具、中文版式、文字工具、中文数字分节、内码转换、首字下沉、带圈字符。 科教功能 产品提供涵盖数学、物理、化学、生物、地理、语言等多个领域，2000多种常用素材和多种管理工具。用户也可根据需要通过科教管理器或科教面板进行素材的管理和使用。产品支持素材的自定义，数理化公式编辑，实验器材以及生物地理等素材应用，函数图像动态呈现等实用的科教功能。 国际化 遵循国际化标准，支持双向文本编辑。提供简体中文、繁体中文、英文、日文、阿拉伯文、法文、西班牙文等多种语言版本，蒙文，俄罗斯文等语言版本正在开发中。 功能完备 几乎全面覆盖了微软Office 2003之Excel、Word、PowerPoint所有功能，并有诸多实用的创新功能，既能满足用户的传统办公需要，又能带给用户很多创新的体验。 二次开发 永中Office针对企业应用系统开发整合需求，在二次开发方面参照微软Office定义和实现的二次开发接口，结合永中Office的自主创新，用JAVA语言设计出了一整套Office接口和对象层次，使得熟悉面向对象设计的程序员更加容易地对永中Office进行二次开发。 永中Office提供功能强大的宏编辑器和丰富的二次开发接口API，支持Office内部开发和外部调用。宏编辑器（MacroEditor）可编辑和运行Java代码，开发环境简单易学。永中Office提供了符合COM规范的接口，通过COM接口可支持使用C++、VB、Delphi等开发语言调用Office功能。永中Office可通过Applet方式或ActiveX方式嵌入浏览器或者其他应用程序运行。通过插件可对Office内部功能进行扩展，永中公司提供了基于永中Office的插件规范，按照该规范开发的第三方插件，均可在永中产品中应用。 永中Office 2010全面支持电子政务平台，能够实现OA系统平滑移植，满足政府和企业信息化的需求。 分数 ⋆ ⋆ ⋆ ⋆\\star\\ \\star\\ \\star\\ \\star⋆ ⋆ ⋆ ⋆（文件太大，功能繁琐） 石墨文档 石墨文档是中国一款支持云端实时协作的企业办公服务软件（功能类比于Google Docs、Quip），可以实现多人同时在同一文档及表格上进行编辑和实时讨论，同步响应速度达到毫秒级。 支持文档格式 评价 1、实时保存 文档/表格实时保存在云端，即写即存。在编辑过程中，文档页面上方会实时提示文档的状态，包括正在保存、保存成功和最后更新时间。 2、轻松分享 添加协作者，邀请小伙伴来一起协作，你可以自行控制文档/表格的协作权限，只读/可写/私有，或协作或私密。 3、实时协作 实时协作可以多人多平台同时编辑在线文档和表格。 4、还原历史 所有的编辑历史都将自动保存，随时追溯查看，还可一键还原到任一历史版本。 分数 ⋆ ⋆ ⋆\\star\\ \\star\\ \\star⋆ ⋆ ⋆（功能比较少） Onedrive For Business 如果你们的学校/公司的邮箱登陆界面是这样的。。。 简单来说，如果你们的组织使用的是Office邮箱系统，那么恭喜你，你有1T的免费存储空间。。。 比如说这是我的 细细看来好像没有基本版office。。。 这里的Office Online 并没有挂 内容经过处理，但是大部分功能都有。 还有很多我不知道干什么的软件 好了，这就是总结的几个可以替代Office的软件了，希望大家喜欢。 ","link":"https://hesy-zhoulijie.github.io/post/free-word/"},{"title":"北斗卫星为你做了什么？","content":"北斗卫星为你做了什么？ 2020 年 6 月 23 日，一枚长三乙运载火箭在西昌卫星发射中心顺利点火、升空。 经过近 26 分钟的飞行、调姿，将位于顶部仪器舱的导航卫星送入预定轨道，成功完成了北斗全球卫星导航系统的星座部署。 这是北斗三号的最后一颗全球组网卫星。7 月 29 日，北斗官方宣布这颗卫星已经完成在轨测试，正式入网工作。 北斗系统究竟意味着什么？覆盖全球的精准定位到底有多难? 利用卫星实现导航定位的技术称为 GNSS（Global Navigation Satellite System）全球卫星导航系统，今天主要有美国的 GPS、俄罗斯的格洛纳斯、欧盟的伽利略，以及中国的北斗。 建设这样一个能覆盖全球的卫星导航系统并不容易。 中国从 1994 年开始，分三步建设北斗卫星导航系统。 在 2000 年发射了两颗卫星，建成北斗一号，为中国用户提供服务；2012 年完成 14 颗卫星发射，建成北斗二号，服务范围扩大至亚太地区；2020 年完成 30 颗卫星发射、组网，全面建成北斗三号，覆盖全球。 事实上，北斗在 26 年间一共发射了 59 颗卫星，目前除去退役、失效和用于试验的，有 45 颗卫星正常在轨工作，数量要多于其他三个系统。 此外，北斗的星座架构也不同。 GPS、格洛纳斯、伽利略的卫星基本都处在高度约 20,000 千米的中圆地球轨道。投影在地球上的是这种波浪状的运行轨迹，卫星分时段覆盖不同的区域，多颗卫星环绕覆盖全球。 而北斗除了在中圆地球轨道有 27 颗卫星，环绕全球外，还有 10 颗在倾斜地球同步轨道，8 字形的轨迹可以增强亚太地区的信号覆盖；还有 8 颗在地球静止轨道，能全时段服务于亚太地区。 更多的卫星和轨道类型增强了北斗对全球，尤其是东半球的覆盖。 这两张图是北斗和 GPS 现役卫星的运行轨迹。 而这是两者在全球任意地点可见的卫星数目图，颜色越深，当地可见的卫星越多。北斗在东半球大部分区域可见的卫星能达到 14~16 颗乃至更多，在其他地区也至少能见到 6 颗。 那么这些卫星是如何实现全球定位的呢？ 当你在地球上某个位置，拿着一个可以接收卫星信号的设备，比如手机，而天上飞着卫星，此时想要求取你在空间中的坐标 x、y、z，关键是测量卫星跟你之间的距离 S。 首先，通过卫星的星历数据能计算出卫星的坐标 x1、y1、z1，这些是已知的。 只需要根据勾股定理求立方体的对角线长度，就能用这个式子表示卫星跟你之间的距离 S。 其次，卫星发出的电磁波信号也能测距。已知电磁波传播的速度，光速 c 每秒近 30 万公里（299,792,458 m/s），乘上电磁波从卫星发出到手机接收所耗费的时间 tB-tA， 即为距离。 这个时间和距离的计算实际上要靠测距码。 卫星和手机会同时按相同规则持续生成一段测距码，而卫星会将测距码通过电磁波发送给手机。 但发送过程需要时间，所以手机接收到卫星发来的测距码时，会发现和自己生成的测距码有偏移，即为电磁波传播的时间。 以北斗的 B1C 信号为例，测距码速率为 1.023 Mbps，单个码片的宽度为速率的倒数，即 0.977517 μs。当偏移了 12 万个码片，即电磁波传播时间约为 0.117 秒，可算出距离约为 35,166 公里。 知道距离，就可以得到这个等式，其中三个未知量 x、y、z 仍然无法求解。但只要有 3 颗卫星，就能列出 3 个等式构成方程组，进而求出你的坐标 x、y、z。 看起来似乎轻松又简单，然而，得到这样的坐标根本不准。 因为里面任何参数哪怕再小的误差都会让定位大幅偏移，比如电磁波传播的时间，只要 0.000001 秒的误差，计算距离就会变化 300 米。 为了减小这个误差，我们首先得考虑在卫星上的钟准不准。 今天北斗卫星上搭载的原子钟，精度可达 300 万年只差一秒，但在太空中运行，它却会遭遇相对论效应。 简单来说，根据狭义相对论，卫星相对地面快速运动，那么从地面观测卫星上的时间会变慢。 而根据广义相对论，卫星相比地面离地心更远，拥有的引力势能绝对值也更小，时间又会比地面更快。 两者对卫星上时钟的综合影响就是比地面上的钟走得更快，其变化量可以用这个公式表示。 那么如何才能消去这个变化量呢？ 公式的前半部分可以通过地心引力常数 μ、光速 c 等数值计算得出。假设卫星在距离地心 36,000 公里的圆轨道运行，那么卫星上的时间会比地面每秒快上 0.00000000051 秒左右。 消除这部分的变化量可以在卫星发射之前就按一定倍数先调低卫星上原子钟的频率，让它走得更慢。 但卫星实际运行的轨道其实是椭圆，由相对论效应引发的变化会有周期性变化，主要是公式的后半部分。 当然，这也可以通过轨道偏心率、长半轴、偏近点角等参数计算得出数值实时修正。 但这还不够，原子钟在无人维护情况下本身运行时仍有误差，卫星坐标在计算时也有误差，电磁波在大气中传播时受电离层、对流层影响速度也会变化。 不过别担心，今天已经有各种各样的数学模型可以计算出这些误差的数值。 然而，还有个麻烦的误差，就是地面接收机的时间误差。像手机这类设备会因为各种各样的原因出现误差，且误差大小很难直接计算修正。 别慌！ 我们可以把这个误差也设为一个未知量，引入第 4 颗卫星，得到四个等式就能求出接收机的时间误差和坐标这四个未知量，进而更精确地确定你的位置。 当然，北斗实现精准定位的技术远远不止这些。今天，北斗可以做到在全球的定位精度优于 10 米，在亚太地区的定位精度优于 5 米。 且通过基于大量地面基准站的地基增强、星基增强等方式，更能实现分米级、厘米级乃至后处理毫米级的高精度定位。 这种技术实力的应用在当代生活中已经随处可见。从大坝监测、电力通信、精准农业，到公交车、共享单车、手机，你都可以看到北斗的身影。 而在这个利用卫星实现全球定位的过程中，凝结了无数科学家、工程师对于误差的锱铢必较。 所以当你再仰望苍穹时，别忘了北斗除了有七星之外，还有 45 颗卫星漂浮在数万公里的高空，让你得知自己身在何处，又去往何方。 src=https://sspai.com/post/61857 ","link":"https://hesy-zhoulijie.github.io/post/beidou/"},{"title":"C++ STL 迭代器","content":"C++ STL 迭代器 STL概述的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得变得非常通用。例如，由于的函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。 [TOC] 要点 STL算法作为模板函数提供。为了和其他组件相区别，以后接一对圆括弧的方式表示，例如sort()sort()sort()。 STL另一个重要特性是它不是面向对象的。为了具有足够通用性，主要依赖于模板而不是封装，继承和虚函数（多态性）的三个要素。你在中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得的组件具有广泛通用性的底层特征。另外，由于是基于模板，内联函数的使用使得生成的代码短小高效。 提示 确保在编译使用了STL的 程序中至少要使用-O优化来保证内联扩展。 STL 组件 STL提供了大量的模板类和函数，可以在OOP和常规 编程中使用。所有的STL的大约50个算法都是完全通用的，而且不依赖于任何特定的数据类型。下面的小节说明了三个基本的STL 组件： 1）迭代器提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指 针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象。 2）容器是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。 3）算法是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象。 函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。 头文件 为了避免和其他头文件冲突， STL的头文件不再使用常规的.h扩展。为了包含标准的string类，迭代器和算法，用下面的指示符： #include &lt;string&gt; #include &lt;iterator&gt; #include &lt;algorithm&gt; 如果你查看STL的头文件，你可以看到象iterator.h和stl_iterator.h这样的头文件。由于这些名字在各种STL实现之间都可能不同，你应该避免使用这些名字来引用这些头文件。为了确保可移植性，使用相应的没有.h后缀的文件名。表1列出了最常使用的各种容器类的头文件。该表并 不完整，对于其他头文件，我将在本章和后面的两章中介绍。 表 1. STL头文件和容器类 #include Container Class deque list map, multimap queue, priority_queue set, multiset stack vector, vector 名字空间 你的编译器可能不能识别名字空间。名字空间就好像一个信封，将标志符封装在另一个名字中。标志符只在名字空间中存在，因而避免了和其他标志符冲突。例如，可能有其他库和 程序模块定义了sort()函数，为了避免和STL地sort()算法冲突，STL的sort()以及其他标志符都封装在名字空间std中。STL的sort()算法编译为std::sort()，从而避免了名字冲突。 尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的#include指示符的后面： using namespace std; ``` ## 迭代器 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器不仅仅是指针，因此你不能认为他们一定具有地址值。例如，一个数组索引，也可以认为是一种迭代器。 迭代器有各种不同的创建方法。程序可能把迭代器作为 一个变量创建。一个STL容器类可能为了使用一个特定类型的数据而创建一个迭代器。作为指针，必须能够使用*操作符类获取数据。你还可以使用其他数学操作 符如$++$。典型的，++操作符用来递增迭代器，以访问容器中的下一个对象。如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成past-the- end值。使用一个past-the-end值得指针来访问对象是非法的，就好像使用NULL或为初始化的指针一样。 ### 提示 STL不保证可以从另一个迭代器来抵达一个迭代器。例如，当对一个集合中的对象排序时，如果你在不同的结构中指定了两个迭代器，第二个迭代器无法从第一个迭代器抵达，此时程序注定要失败。这是STL灵活性的一个代价。STL不保证检测毫无道理的错误。 ### 迭代器的类型 对于STL数据结构和算法，你可以使用五种迭代器。下面简要说明了这五种类型： - Input iterators 提供对数据的只读访问。 - Output iterators 提供对数据的只写访问 - Forward iterators 提供读写操作，并能向前推进迭代器。 - Bidirectional iterators提供读写操作，并能向前和向后操作。 - Random access iterators提供读写操作，并能在数据中随机移动。 尽管各种不同的STL实现细节方面有所不同，还是可以将上面的迭代器想象为一种类继承关系。从这个意义上说，下面的迭代器继承自上面的迭代器。由于 这种继承关系，你可以将一个Forward迭代器作为一个output或input迭代器使用。同样，如果一个算法要求是一个bidirectional 迭代器，那么只能使用该种类型和随机访问迭代器。 ### 指针迭代器 正如下面的小程序显示的，一个指针也是一种迭代器。该程序同样显示了STL的一个主要特性——它不只是能够用于它自己的类类型，而且也能用于任何C或C++类型。 Listing 1, iterdemo.cpp, 显示了如何把指针作为迭代器用于STL的find()算法来搜索普通的数组。 ```cpp #include &lt;iostream.h&gt; #include &lt;algorithm&gt; using namespace std; #define SIZE 100 int iarray[SIZE]; int main() { iarray[20] = 50; int* ip = find(iarray, iarray + SIZE, 50); if (ip == iarray + SIZE) cout &lt;&lt; &quot;50 not found in array&quot; &lt;&lt; endl; else cout &lt;&lt; *ip &lt;&lt; &quot; found in array&quot; &lt;&lt; endl; return 0; } ``` 在引用了I/O流库和STL算法头文件（注意没有.h后缀），该 程序告诉编译器使用std名字空间。使用std名字空间的这行是可选的，因为可以删除该行对于这么一个小程序来说不会导致名字冲突。 程序中定义了尺寸为SIZE的全局数组。由于是全局变量，所以运行时数组自动初始化为零。下面的语句将在索引20位置处地元素设置为50,并使用find()算法来搜索值50: ```cpp iarray[20] = 50; int* ip = find(iarray, iarray + SIZE, 50); ``` find() 函数接受三个参数。头两个定义了搜索的范围。由于C和C++数组等同于指针，表达式`iarray`指向数组的第一个元素。而第二个参数`iarray + SIZE`等同于`past-the-end` 值，也就是数组中最后一个元素的后面位置。第三个参数是待定位的值，也就是50。find()函数返回和前两个参数相同类型的迭代器，这儿是一个指向整数 的指针ip。 提示 必须记住STL使用模板。因此，STL函数自动根据它们使用的数据类型来构造。 为了判断find()是否成功，例子中测试ip和 past-the-end 值是否相等： ```cpp if (ip == iarray + SIZE) ... ``` 如果表达式为真，则表示在搜索的范围内没有指定的值。否则就是指向一个合法对象的指针，这时可以用下面的语句显示： ```cpp cout &lt;&lt; *ip &lt;&lt; &quot; found in array&quot; &lt;&lt; endl; ``` 测试函数返回值和$NULL$是否相等是不正确的。不要象下面这样使用： ``` cpp int* ip = find(iarray, iarray + SIZE, 50); if (ip != NULL) ... // ??? incorrect ``` 当使用STL函数时，只能测试`ip`是否和`past-the-end` 值是否相等。尽管在本例中ip是一个C++指针,其用法也必须符合STL迭代器的规则。 ### 容器迭代器 尽管C++指针也是迭代器，但用的更多的是容器迭代器。容器迭代器用法和iterdemo.cpp一样，但和将迭代器申明为指针 变量不同的是，你可以使用容器类方法来获取迭代器对象。两个典型的容器类方法是`begin()`和`end()`。它们在大多数容器中表示整个容器范围。其他一 些容器还使用`rbegin()`和`rend()`方法提供反向迭代器，以按反向顺序指定对象范围。 下面的 程序创建了一个矢量容器（STL的和数组等价的对象），并使用迭代器在其中搜索。该 程序和前一章中的程序相同。 ```cpp Listing 2. vectdemo.cpp #include &lt;iostream.h&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; intVector(100); void main() { intVector[20] = 50; vector&lt;int&gt;::iterator intIter = find(intVector.begin(), intVector.end(), 50); if (intIter != intVector.end()) cout &lt;&lt; &quot;Vector contains value &quot; &lt;&lt; *intIter &lt;&lt; endl; else cout &lt;&lt; &quot;Vector does not contain 50&quot; &lt;&lt; endl; } ``` 注意用下面的方法显示搜索到的数据： ```cpp cout &lt;&lt; &quot;Vector contains value &quot; &lt;&lt; *intIter &lt;&lt; endl; ``` ### 常量迭代器 和指针一样，你可以给一个迭代器赋值。例如，首先申明一个迭代器：``` vector&lt;int&gt;::iterator first;``` 该语句创建了一个`vector&lt;int&gt;`类的迭代器。下面的语句将该迭代器设置到```int Vector```的第一个对象，并将它指向的对象值设置为123： ```cpp first = intVector.begin(); *first = 123; ``` 这种赋值对于大多数容器类都是允许的，除了只读变量。为了防止错误赋值，可以申明迭代器为： ```cpp const vector&lt;int&gt;::iterator result; result = find(intVector.begin(), intVector.end(), value); if (result != intVector.end()) *result = 123; // ??? ``` ","link":"https://hesy-zhoulijie.github.io/post/cppiter/"},{"title":"C++中的inline用法","content":"C++中的inline用法[1] 目录 [toc] 1. 引入inline关键字的原因 在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。 栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。 在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。 下面我们来看一个例子： #include &lt;stdio.h&gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) { return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;; } int main() { int i = 0; for (i=1; i &lt; 100; i++) { printf(&quot;i:%d 奇偶性:%s /n&quot;, i, dbtest(i)); } } 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for循环的内部任何调用*dbtest(i)*的地方都换成了*(i%2&gt;0)?”奇”:”偶”*，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。 2. inline使用限制 inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。 3. inline仅是一个对编译器的建议 inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。 4. 建议：inline函数的定义放在头文件中 其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。 因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。 5. 类中的成员函数与inline 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。 例如， class A { public:void Foo(int x, int y) { } // 自动地成为内联函数 } 将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成： // 头文件 class A { public: void Foo(int x, int y); } // 定义文件 inline void A::Foo(int x, int y){} 6. inline 是一种“用于实现的关键字” 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。 如下风格的函数Foo 不能成为内联函数： inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y){} 而如下风格的函数Foo 则成为内联函数： void Foo(int x, int y); inline void Foo(int x, int y) {} // inline 与函数定义体放在一起 所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 7. 慎用inline 内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？ 内联是以**代码膨胀（复制）**为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。 8. 总结 内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。 最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！ src=http://suo.im/5DJMtR ↩︎ ","link":"https://hesy-zhoulijie.github.io/post/C++inline/"},{"title":"C++ 关键字auto","content":"C++ 关键字auto[1] 目录 [toc] c++98 auto 早在C++98标准中就存在了auto关键字，那时的auto用于声明变量为自动变量，拥有自动的生命周期；但是该作用是多余的，变量默认拥有自动的生命周期。 int a = 10; // 自动生命周期 auto int b = 20; // 自动生命周期 在C++ 11 中，已经删除了该用法，取而代之的作用是：自动推断变量的类型。 c++11 auto auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型： auto i =100; // i 是 int auto p = new A(); // p 是 A* auto k = 34343LL; // k 是 long long 这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。是否会造成编译期的时间消耗，我认为是不会的，在未使用auto时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。 对于上面的示例，在实际编程中并不推荐，因为不便于他人阅读，直接写出变量的类型会更加的清晰易懂，主要用于代替冗长复杂，变量使用范围专一的变量声明，比如： std::vector&lt;std::string&gt; vec; for (auto iter = vec.begin(); iter != vec.end(); ++iter) {} 在定义函数模板时，用于声明依赖模板参数的变量类型，模板函数依赖于模板参数的返回值： template&lt;typename Tx, typename Ty&gt; auto multiply(Tx x, Ty y) // c++14 { return x * y; } auto使用注意事项 （1）auto 变量必须在定义时初始化，这类似于const关键字； （2）定义在一个auto序列的变量必须始终推导成同一类型，如： auto a = 1, b = 2, c = 3; // 正确 auto a = 1, b = 2.2, c = 'c'; // 错误（这个道理和第一点注意事项相同） （3）如果初始化表达式是引用，则去除引用语义，如： int a = 1; int &amp;b = a; auto c = b; // 此时c的类型被推导为 int32，而不是int32&amp; auto &amp;c = b; // 此时c的类型才是int&amp; （4）如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义。 const int a = 10; auto b= a; // b的类型为int而非const int（去除const） const auto c = a; // 此时c的类型为const int b = 100; // 合法 c = 100; // 非法 （5）如果auto关键字带上&amp;号，则不去除const语义。 const int a = 10; auto &amp;b = a; // 因为auto带上&amp;，故不去除const，b类型为const int b = 10; /非法 （6）初始化表达式为数组时，auto关键字推导类型为指针。 int a[3] = { 1, 2, 3 }; auto b = a; std::cout &lt;&lt; typeid(b).name() &lt;&lt; std::endl; // 这里输出 int* （7）如果表达式为数组且auto带上&amp;，则推导类型为数组类型。 int a[3] = { 1, 2, 3 }; auto &amp;b = a; std::cout &lt;&lt; typeid(b).name() &lt;&lt; std::endl; // 这里输出 int[3] （8）函数或模板参数不能被声明为auto。 void func(auto a) // 错误 { //... } （9）auto不是一个真正的类型，仅仅是一个占位符，不能使用一些以类型为操作数的操作符，如sizeof或typeid： std::cout &lt;&lt; sizeof(auto) &lt;&lt; std::endl; // 错误 std::cout &lt;&lt; typeid(auto).name() &lt;&lt; std::endl; // 错误 src=http://suo.im/67P9DK ↩︎ ","link":"https://hesy-zhoulijie.github.io/post/cppauto/"},{"title":"数据结构百科全书","content":"数据结构 整理不易，全文比较长，而且有很多的代码段，建议收藏。 [toc] vector (动态数组) 的使用` 文件名 vector.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件vector，在代码头部写下 #include &lt;vector&gt; 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何使用一维的vector。 在main函数里面通过vector&lt;int&gt; v来定义一个储存整数的空的vector。当然vector可以存任何类型的数据，比如vector&lt;string&gt; v等等。在本课中我们用 int 来举例。 vector&lt;int&gt; v; 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; return 0; } 第三步 讲解 我们把 111 到 101010 的平方依次存到vector。 在刚才的定义下面写下 for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } return 0; } 第四步 讲解 然后依次输出我们刚才压入vector的值。继续写下 for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0; } 第五步 讲解 到这里，里可以点击运行看看效果。 接下来我们学习二维的vector的使用。二维的vector就是一个vector里面在套一个vector。通过如下的代码定义一个空的二维的vector。在刚才的输出代码后面继续写下，特别注意：里面的vector&lt;int&gt;后面有一个空格，这个空格不能到少，因为在没有开启 c++11 的情况下，会被识别成一个&gt;&gt;。 vector&lt;vector&lt;int&gt; &gt; v2d; 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; return 0; } 第六步 讲解 接下来我们给第一维赋值，第一维是一个一维的vector，在定义后面写下： for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } return 0; } 第七步 讲解 我们让第 iii 行第 jjj 列的元素的值为 i∗ji*ji∗j。继续写下下面的代码： for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; 5; ++j) { v2d[i].push_back(i * j); } } 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; 5; ++j) { v2d[i].push_back(i * j); } } return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; 5; ++j) { v2d[i].push_back(i * j); } } return 0; } 第八步 讲解 然后我们输出一个 555 行 555 列的矩阵。 for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; v2d[i].size(); ++j) { cout &lt;&lt; v2d[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } 提示 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; 5; ++j) { v2d[i].push_back(i * j); } } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; v2d[i].size(); ++j) { cout &lt;&lt; v2d[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v; for (int i = 1; i &lt;= 10; ++i) { v.push_back(i * i); } for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; vector&lt;vector&lt;int&gt; &gt; v2d; for (int i = 0; i &lt; 5; ++i) { v2d.push_back(vector&lt;int&gt;()); } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; 5; ++j) { v2d[i].push_back(i * j); } } for (int i = 0; i &lt; v2d.size(); ++i) { for (int j = 0; j &lt; v2d[i].size(); ++j) { cout &lt;&lt; v2d[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果。 聪明的你一定学会了vector怎么用了。 set (配对) 的使用` 文件名 set.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件set，在代码头部写下 #include &lt;set&gt; 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何创建一个set。 在main函数里面通过set&lt;string&gt; country来定义一个储存字符串的空的set。当然set可以存任何类型的数据，比如set&lt;int&gt; s等等。在本课中我们用 string 来举例。 set&lt;string&gt; country; 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; return 0; } 第三步 讲解 我们把China America France依次插入到set。 在刚才的定义下面写下 country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); return 0; } 第四步 讲解 然后依次输出我们刚才插入set的字符串。继续写下 set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0; } 第五步 讲解 到这里，里可以点击运行看看效果。 可以发现我们刚才插入的字符串按照字典序排列好了。 接下来我们学习set的删除操作。 country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); return 0; } 第六步 讲解 接下来我们统计set中China字符串的个数 if (country.count(&quot;China&quot;)) { cout &lt;&lt; &quot;China in country.&quot; &lt;&lt; endl; } 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); if (country.count(&quot;China&quot;)) { cout &lt;&lt; &quot;China in country.&quot; &lt;&lt; endl; } return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); if (country.count(&quot;China&quot;)) { cout &lt;&lt; &quot;China in country.&quot; &lt;&lt; endl; } return 0; } 第七步 讲解 最后我们将使用完成的set清空。继续写下下面的代码： country.clear(); 提示 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); if (country.count(&quot;China&quot;)) { cout &lt;&lt; &quot;China in country.&quot; &lt;&lt; endl; } country.clear(); return 0; } 代码 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;string&gt; country; country.insert(&quot;China&quot;); country.insert(&quot;America&quot;); country.insert(&quot;France&quot;); set&lt;string&gt;::iterator it; for (it = country.begin(); it != country.end(); ++it) { cout &lt;&lt; * it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; country.erase(&quot;American&quot;); country.erase(&quot;England&quot;); if (country.count(&quot;China&quot;)) { cout &lt;&lt; &quot;China in country.&quot; &lt;&lt; endl; } country.clear(); return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果。 聪明的你一定学会了set怎么用了。 map (字典) 的使用` 文件名 map.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件map，在代码头部写下 #include &lt;map&gt; #include &lt;string&gt; 代码 #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何创建一个map。 在main函数里面通过map&lt;string, int&gt; dict来定义一个key:value映射关系的空的map。当然map可以存任何类型的数据，比如map&lt;int, int&gt; m等等。在本课中我们用string:int来举例。 map&lt;string, int&gt; dict; 提示 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; return 0; } 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; return 0; } 第三步 讲解 我们把Tom Jone Mary依次插入到map并一一对应的赋值。 在刚才的定义下面写下 dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; 提示 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; return 0; } 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; return 0; } 第四步 讲解 接下来我们查看map中Mary对应的value值，先判断一下map中是否有Mary。继续写下 if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } 提示 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } return 0; } 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } return 0; } 第五步 讲解 到这里，里可以点击运行看看效果。 接下来我们学习map的遍历操作。 for (map&lt;string, int&gt;::iterator it = dict.begin(); it != dict.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is in class &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } 提示 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } for (map&lt;string, int&gt;::iterator it = dict.begin(); it != dict.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is in class &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } return 0; } 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } for (map&lt;string, int&gt;::iterator it = dict.begin(); it != dict.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is in class &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } return 0; } 第六步 讲解 到这里，里可以点击运行看看效果。 可以发现map里的key字符串按照字典序排列好了。 最后我们再清空map dict.clear(); 提示 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } for (map&lt;string, int&gt;::iterator it = dict.begin(); it != dict.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is in class &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } dict.clear(); return 0; } 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;string, int&gt; dict; dict[&quot;Tom&quot;] = 1; dict[&quot;Jone&quot;] = 2; dict[&quot;Mary&quot;] = 1; if (dict.count(&quot;Mary&quot;)) { cout &lt;&lt; &quot;Mary is in class &quot; &lt;&lt; dict[&quot;Mary&quot;]; } for (map&lt;string, int&gt;::iterator it = dict.begin(); it != dict.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is in class &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } dict.clear(); return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果。 聪明的你一定学会了map怎么用了。 stack (栈) 的使用` 文件名 stack.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件stack，在代码头部写下 #include &lt;stack&gt; 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何使用stack。 在main函数上方通过stack&lt;int&gt; S来定义一个全局栈来储存整数的空的stack。当然stack可以存任何类型的数据，比如stack&lt;string&gt; S等等。在本课中我们用 int 来举例。 stack&lt;int&gt; S; 提示 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { return 0; } 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { return 0; } 第三步 讲解 我们把1 10 7三个数依次存到stack。 在main函数里写下 S.push(1); S.push(10); S.push(7); 提示 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); return 0; } 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); return 0; } 第四步 讲解 然后我们判断一下stack的是否为空。继续写下 while (!S.empty()) { } 提示 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); while (!S.empty()) { } return 0; } 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); while (!S.empty()) { } return 0; } 第五步 讲解 如果stack不为空，我们将stack里的数依次取出来，在while里继续写下 cout &lt;&lt; S.top() &lt;&lt; endl; S.pop(); 提示 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); while (!S.empty()) { cout &lt;&lt; S.top() &lt;&lt; endl; S.pop(); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; stack&lt;int&gt; S; int main() { S.push(1); S.push(10); S.push(7); while (!S.empty()) { cout &lt;&lt; S.top() &lt;&lt; endl; S.pop(); } return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果，可以发现stack有先进后出的特性。 聪明的你一定学会了stack怎么用了。 queue (队列) 的使用` 文件名 queue.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件queue，在代码头部写下 #include &lt;queue&gt; 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何使用queue。 在main函数里面通过queue&lt;int&gt; q来定义一个储存整数的空的queue。当然queue可以存任何类型的数据，比如queue&lt;string&gt; q等等。在本课中我们用 int 来举例。 queue&lt;int&gt; q; 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; return 0; } 第三步 讲解 我们把1 2 3三个数依次存到queue。 在main函数里写下 q.push(1); q.push(2); q.push(3); 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); return 0; } 第四步 讲解 然后我们判断一下queue的是否为空。继续写下 while (!q.empty()) { } 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { } return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { } return 0; } 第五步 讲解 如果queue不为空，我们将queue里的数依次取出来，在while里继续写下 cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); } return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果，可以发现queue有先进先出的特性。 聪明的你一定学会了queue怎么用了。 priority_queue (优先队列) 的使用` 文件名 priority_queue.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们引入需要的头文件queue，在代码头部写下 #include &lt;queue&gt; 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { return 0; } 第二步 讲解 首先我们学习如何使用priority_queue。 在main函数里面通过priority_queue&lt;int&gt; q来定义一个储存整数的空的priority_queue。当然priority_queue可以存任何类型的数据，比如priority_queue&lt;string&gt; q等等。在本课中我们用 int 来举例。 priority_queue&lt;int&gt; q; 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; return 0; } 第三步 讲解 我们把1 2 3三个数依次存到priority_queue。 在main函数里写下 q.push(1); q.push(2); q.push(3); 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); return 0; } 第四步 讲解 然后我们判断一下priority_queue的是否为空。继续写下 while (!q.empty()) { } 提示 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { } return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { } return 0; } 第五步 讲解 如果priority_queue不为空，我们将priority_queue里的数依次取出来，在while里继续写下 cout &lt;&lt; q.top() &lt;&lt; endl; q.pop(); 提示 #include &lt;iostream&gt; #include &lt;priority_queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { cout &lt;&lt; q.top() &lt;&lt; endl; q.pop(); } return 0; } 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { cout &lt;&lt; q.top() &lt;&lt; endl; q.pop(); } return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果，可以发现priority_queue会自动从大到小排好序。 聪明的你一定学会了priority_queue怎么用了。 disjoint (并查集) 的使用` 文件名 disjoint.cpp 分数 1 初始化代码 #include &lt;iostream&gt; using namespace std; int main() { return 0; } 第一步 讲解 首先我们需要定义节点个数n，father父节点数组，dist距离数组，size权值数组，在main函数上方写下 int father[110], n; int dist[110], size[110]; 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; int main() { return 0; } 第二步 讲解 然后对这些数组进行初始化。在main函数里写下 n = 10; init(); 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; int main() { n = 10; init(); return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; int main() { n = 10; init(); return 0; } 第三步 讲解 接下来具体实现init函数。继续在main函数上面写下 void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int main() { n = 10; init(); return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int main() { n = 10; init(); return 0; } 第四步 讲解 现在开始学习并查集的merge操作，我们将1和2、10和7、3和4、3和7合并。在main函数里继续写下 merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); return 0; } 第五步 讲解 接下来我们具体实现merge函数。在main上方继续写下 void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); return 0; } 第六步 讲解 接下来我们查找1所在集合的根节点并输出1到根节点的距离dist。在main函数里继续写下 get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; return 0; } 第七步 讲解 我们接着实现get函数。在merge函数上方继续写下 int get(int x) { if (father[x] == x) { return x; } int y = father[x]; father[x] = get(y); dist[x] += dist[y]; return father[x]; } 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int get(int x) { if (father[x] == x) { return x; } int y = father[x]; father[x] = get(y); dist[x] += dist[y]; return father[x]; } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int get(int x) { if (father[x] == x) { return x; } int y = father[x]; father[x] = get(y); dist[x] += dist[y]; return father[x]; } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; return 0; } 第八步 讲解 到这里，里可以点击运行看看效果。 接下来我们查找3所在集合的根节点并输出3到根节点的距离dist。在main函数里继续写下 get(3); cout &lt;&lt; dist[3] + 1 &lt;&lt; endl; 提示 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int get(int x) { if (father[x] == x) { return x; } int y = father[x]; father[x] = get(y); dist[x] += dist[y]; return father[x]; } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; get(3); cout &lt;&lt; dist[3] + 1 &lt;&lt; endl; return 0; } 代码 #include &lt;iostream&gt; using namespace std; int father[110], n; int dist[110], size[110]; void init() { for (int i = 1; i &lt;= n; ++i) { father[i] = i, dist[i] = 0, size[i] = 1; } } int get(int x) { if (father[x] == x) { return x; } int y = father[x]; father[x] = get(y); dist[x] += dist[y]; return father[x]; } void merge(int a, int b) { a = get(a); b = get(b); if (a != b) { father[a] = b; dist[a] = size[b]; size[b] += size[a]; } } int main() { n = 10; init(); merge(1, 2); merge(10, 7); merge(3, 4); merge(3, 7); get(1); // 一定要先 get，可能没有直接连接根节点 cout &lt;&lt; dist[1] + 1 &lt;&lt; endl; get(3); cout &lt;&lt; dist[3] + 1 &lt;&lt; endl; return 0; } 完成讲解 这一节已经完成了，赶紧运行看看效果。 聪明的你一定学会了disjoint怎么用了。 队列` 简介 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 重要特性：元素先进先出 实现方式 数组 链表 STL 标程 #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; using namespace std; struct Queue { /* 数组实现 */ void Queue_Array() { int q[1005] = {0}; int head = 0; int tail = head; q[tail++] = 1; q[tail++] = 2; q[tail++] = 3; while (head &lt; tail) { printf(&quot;%d\\n&quot;, q[head]); head++; } } /* STL实现 */ void Queue_STL() { queue&lt;int&gt; q; q.push(1); q.push(2); q.push(3); while (!q.empty()) { printf(&quot;%d\\n&quot;, q.front()); q.pop(); } } }Q; int main() { Q.Queue_Array(); Q.Queue_STL(); return 0; } 单调队` 简介 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。 重要特性：元素可以从两端进出 实现方式 数组 链表 STL deque的性质 容器中间插入和删除效率很低 与vector容器操作类似 例题 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4286 题意：n个数字一开始排成一行，有两个指针L和R，指向了这串数字的一个区间的端点。 现在有7种操作 使一个指针左移 使一个指针右移 在L后插入一个数字X 在R前插入一个数字X 删除L所指元素 删除R所指元素 翻转[L,R]区间 Question：m次操作后，整串数字是什么样的？ 分析：如果区间L和R每一次都是任意范围的，那么肯定是平衡树问题。但是现在区间断点L和R每次只能左移一位或右移一位，那么可以将整串数字以L、R为中点分为三段，然后模拟这几种操作。但是翻转不能直接模拟，用一个标记来判断一下正反。 双端队列` 简介 双端队列（deque，全名double-ended queue）是一个限定插入和删除操作的数据结构，具有队列和栈的性质。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。 双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称做端点1和端点2。也可像栈一样，可以用一个铁道转轨网络来比喻双端队列。 重要特性：元素可以从两端进出 实现方式 数组 链表 STL deque的性质 容器中间插入和删除效率很低 与vector容器操作类似 例题 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4286 题意：n个数字一开始排成一行，有两个指针L和R，指向了这串数字的一个区间的端点。 现在有7种操作 使一个指针左移 使一个指针右移 在L后插入一个数字X 在R前插入一个数字X 删除L所指元素 删除R所指元素 翻转[L,R]区间 Question：m次操作后，整串数字是什么样的？ 分析：如果区间L和R每一次都是任意范围的，那么肯定是平衡树问题。但是现在区间断点L和R每次只能左移一位或右移一位，那么可以将整串数字以L、R为中点分为三段，然后模拟这几种操作。但是翻转不能直接模拟，用一个标记来判断一下正反。 标程 #include&lt;algorithm&gt; #include&lt;deque&gt; #include&lt;iostream&gt; using namespace std; int main() { deque&lt;int&gt; dq; dq.push_back(1); dq.push_back(2); dq.push_back(3); dq.push_front(4); dq.push_front(5); dq.push_front(6); dq.pop_back(); dq.pop_front(); deque&lt;int&gt;::iterator it; for (it = dq.begin(); it != dq.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0; } ","link":"https://hesy-zhoulijie.github.io/post/data-structure/"},{"title":"光一直以光速向前传播，可为何光逃离不了黑洞？","content":"光一直以光速向前传播，可为何光逃离不了黑洞？ （本文冗长。最后有一句话比喻，通俗易懂。） 一句话：因为在黑洞内部，光锥是永远向内的。 [toc] 首先解释一个关键的概念，什么是「光锥」。 简单地说，光锥就是光的时空路径——注意是「时空」，而不是「空间」。即，在某时某地发射一闪光，此后光传播所经历到的时空区域就是「光锥」。换句话说，就是能看到这个闪光的时空区域。当然，这严格说是未来光锥。 这样说还是很抽象，举个1维空间的例子。这个世界不妨称之为「1+1维」时空（因为是1维空间+1维时间）。简单起见，假设光速为常数 v=1。 时间 t = 0 时，在空间坐标原点 x = 0 处发生一闪光。这时，因为光以有限的速度 v = 1 传播，其路径就是 x = t 或者 x = - t。这里有两条路径，因为在一维空间里，光能朝「前」、「后」两个方向传播。 画在 (x, t) 平面上，光的时空路径 x = t 或者 x = - t 就是通过原点的45度角射线。这射线就是「1+1维」时空的光锥。如下图所示，红色射线就是光锥。 在这个「1+1维」时空里，只有在光锥上的点，才能看到闪光。比如 (x = 2, t = 1) 这个点，就不在光锥上，也看不到闪光。因为在 t = 1 秒的时候，光还没有传播到 x = 2 处。x = 2 处只有在等到 t = 2 时才能看到闪光，于是 (x = 2, t = 2) 这个点正好就在光锥上。上面这个例子很容易推广到真实的「3+1维」时空（3维空间，1维时间），只不过这时候射线变成了锥子（当然是3维的锥子），所以叫光锥。 所以光锥是时空的一个截面，维度比时空少一维。光锥的存在正是因为光速有限。 更物理地说，光锥是时空的一个「界限」，即，能发生因果关联与否的区分边界。因为光速是最大速度，光在光锥表面传播，其他信号在光锥内部传播，所以光锥内部就是可发生信号联系（因果关联）的区域，光锥外则是不可能有因果关联的区域。 以下图为例（引子wiki） 这里展示的是「2+1维时空」：2维空间（横向）+1维时间（纵向）。A代表某时某地一「事件」，光锥内部（上图黄色区域）就是A事件未来可影响到的时空区域，比如B点（下部黄色区域代表可以过去可能影响过A的时空区域）；而光锥外的其他区域，过去、未来都不可能与A事件发生关联，比如C点。 回到光传播的问题上。 广义相对论说，时空可以弯曲。于是在这个弯曲的时空里，光就不一定走 x = t 或者 x = - t 这么简单的直线了。比如在「1+1维」的时空里，光的路径可能就是这个样子： 根据时空弯曲的程度，光可以走各种扭曲的路径。上图中，虽然光的路径很扭曲，但是左边 x1(t) 还是在朝「左」传播，右边 x2(t) 还是在朝右传播。那么有没有可能扭曲成这个样子：也就是说，无论光自己以为在朝哪个方向传播，实际上都是在朝左传播？ 回答是当然可能！这正是光无法离开黑洞的关键！ 具体而言：对于比较正常的时空里的正常的光锥，光可以（沿着光锥表面）向前后左右任意空间方向传播。但是在黑洞内部，光锥被扭曲，光锥的所有空间方向都朝向黑洞内部，使得光只能向内传播。 以最简单的不带电不旋转黑洞即「Schwarzschild黑洞」为例。 下图（引自wiki）中左边白色区域为黑洞外，右边黑色区域为黑洞内。在左边即黑洞外，光锥比较正常，光可以朝两个方向传播——比如朝左也就是背离黑洞，或者朝右也就是朝向黑洞。 如果我们靠近黑洞，如下图（引自wiki），光锥开始扭曲，明显开始朝黑洞倾斜。于是光倾向于向黑洞（朝右）内传播，只有少部分可以背离黑洞（朝左）。如果我们进入黑洞内部（黑色区域），如下图（引自wiki），这时，光锥完全被扭曲，光锥的任何方向都是指向黑洞内部。也就是说，光无论怎么传播，都是在「朝内」传播。下图（来自网络）是个更形象的说明： 圆柱代表黑洞视界，圆柱内是黑洞内，圆柱外是黑洞外。黑洞外光锥被扭曲的不厉害，光可以朝向黑洞也可以背离黑洞。黑洞里面，光锥完全倒向黑洞内，光锥的所有方向都指向黑洞内，于是光无论朝哪个方向传播都是在向内传播。 总之，一句话，在黑洞（视界）内部，时空被扭曲了——只有向内，没有向外。 最后，如果觉得还是很抽象的话，可以考虑这样的例子（虽然不严谨，但本质上一个道理）： 你在坐高铁，你以为你可以来回走动，但是因为你不可能比高铁走的更快，所以在地面上的人看来，你只能永远在朝前走，就像光在黑洞内只能永远朝里走。 原文链接 转载自知乎日报2013.05.19 ","link":"https://hesy-zhoulijie.github.io/post/blackhole/"},{"title":"如何优雅地使用 Windows 系统？","content":"如何优雅地使用 Windows 系统？ 是否优雅不得而知，仅提供个人用法。 [toc] 1、概览： 这是我的桌面，无杀软。（壁纸出处：塞伦盖蒂国家公园狮子，感谢@棒棒糖elaine） 2、使用云服务 比如 Chrome 的书签同步插件 Xmarks（在天朝自带的同步功能有些鸡肋，但是除了书签之外的数据可以使用自带同步功能）； Evernote 写笔记、GTD、知识系统管理；将平时不用的但是有价值的东西上传到网盘里； 使用同步文件夹，将重要的文件同步上传到云空间；项目都同步到 SVN 或 GitHub 中。 使用云端软件平台（云端 - 创新生活新体验），把软件都装在上面，也可以将本地软件导入平台中（虚拟化），这样即使是重装系统后也无需重装应用，可携带缓存文件夹到不同电脑上使用平台上的软件，无需安装。绿色，便于管理。 3、美化 3.1 如上面有人说的，使用Mactype字体渲染。（优化后效果好很多） 3.2 使用 clover 创建标签式资源管理器窗口（Clover Brings Chrome-Style Tabs to Windows Explorer.） 3.3 使用 NetSpeedMonitor 来监控网速。（FlorianGilles.com） 3.4 用一个快速而且不弹框的好输入法：《小狼毫》（Downloads - rimeime - 下載 Rime 輸入法） 这是相关的介绍：推薦一個神級輸入法——Rime ( 谢谢 @郭家寶 提醒更新） 4**、优化** 定期清理系统垃圾，使用CCleaner（CCleaner - PC Optimization and Cleaning）。 一个月碎片整理一次。使用Defraggler（Defraggler - File and Disk Defragmentation）。 5、其他 优雅地使用Windows唯一的手段就是找到符合自己的操作习惯，把不顺心的情况化解，并乐于挖掘适合自己的功能或者操作，包括快捷键、个性化设置等。 嗯，有人喜欢「番茄工作法」的吗？ 对于精力不集中的人，建议使用Focus Booster，一款小巧优雅的软件。（下载：focus booster） 有人想要一个款优雅的 editor，这里推荐一款性感无比的编辑器：Sublime Text 2（各种配色任你选：daylerees/colour-schemes 路 GitHub） - - Update - - 有人说桌面没有一个图标以及任务栏隐藏就很优雅吗？为什么要学Mac OS？ 我想说：这些都是个人习惯问题，只要用得顺手，在两三步下可以迅速找到自己要用得东西就行了。 精简就一定是Mac的专利？ 写的时候没想到大家反响这么积极啊，弄到我都有些心虚了，谈不上优雅，只能算利用工具提高生产里而已。 还有，上面推荐的软件真不是广告 - _ -|| 原文链接 转载自知乎日报2013.05.19 ","link":"https://hesy-zhoulijie.github.io/post/userwin/"},{"title":"夸克浏览器，轻量但好用的浏览工具","content":" 夸克浏览器，轻量但好用的浏览工具 在谈及浏览器的时候，我们更希望拥有的是一款具有优秀「工具属性」的应用：在相对较少却高度专注的使用情景里，它能够尽最大可能为我们提供更好的网页浏览体验——而不是不由分说地接管你的视线、分散你的注意力，甚至在首页向你推送一些不合口味的「热点新闻」。 换言之，有时候我们需要的是一款「轻量但够用」的浏览工具。除了之前我们介绍过的 Via 和 Ninja 之外，现在 Android 用户又有了一个新的选择，夸克浏览器。 简约精致的视觉风格 夸克浏览器在视觉风格上和 Chrome 浏览器有着些许的相似：主界面 Logo、搜索 / 地址框、快速导航标签自上而下一字排开，下方分别为标签页管理和菜单按钮，除此之外并无其他不必要的信息造成过多的视觉干扰。 标签页管理、菜单和快速导航编辑页面也都采用了卡片堆叠效果，轻巧灵动，无论是阴影还是动效都不会给我们留下半点「廉价感」。 在滚动浏览网页的过程中，网页标题栏将会缩小，多标签管理和菜单按钮也会随之隐藏，为网页内容留出了足够的展示空间。 贴心的细节设计 考虑到现在的手机屏幕越做越大，夸克浏览器并没有像大多数浏览器那样把地址栏放在顶部，而是将整合后的「搜索 / 地址栏」放在了用户更容易操作的底部，常用网址建议会以彩色标签的方式出现在地址栏上方。 同时应用在输入网址时提供了一个快速补全工具条，用于一键输入一些常用的网址符号和后缀，这个工具条中间还放置着一个用于移动输入光标的「摇杆」，进行复杂网址输入时相当有用，长按「摇杆」后还可进行文字选中操作。 夸克浏览器还支持滑动前进/后退、底部上滑返回首页、长按标签管理按钮打开新标签页等一些基本的手势操作，配合「搜索框/地址栏下置」设计，浏览网页的过程中单手操作便能解决大部分网页浏览和导航需求。 不得不提的是，在夸克浏览器的设置当中还埋藏这一个相当强大的**「云端加速」**功能。 尽管从字面上看该功能似乎很多同类浏览器都在做，但在夸克浏览器当中，这个功能的「能力范围」却可以等同于 网页加速 + 广告过滤 + 网页再排版（也叫「酷影模式」）：当你打开豆瓣、淘宝的网页版客户端时，烦人的 App 下载提示被过滤掉了；而校园网、政府网站等各种「老式网站」上面飘来飘去的悬浮窗也会被自动屏蔽掉，极大提升了使用 Web App 和浏览网站网站的体验。 事实上，自其前身「极简浏览器」面世起，这款应用已经经历了数个版本的更迭。好在它一直秉承着一份难能可贵的「克制」：没有选择不断地加入各种臃肿的功能，而是在细节设计和用户体验上进行不断优化，最终在「浏览网页」这件事情上做出了一些不一样的东西。 如果你只需要一款轻量但是又够用浏览器，夸克也许是个不错的选择。你可以前往 豌豆荚 或者 App Store 免费下载。 ","link":"https://hesy-zhoulijie.github.io/post/quark/"},{"title":"使用Air Keyboard在iPad上控制键鼠","content":"使用Air Keyboard在iPad上控制键鼠 其他平台（建议使用第一个链接） 镜像1 : http://suo.im/6lNYqH 镜像2 : http://suo.im/5R3bnC 镜像3 : http://suo.im/6em1ta [toc] 操作方法 在App Store找到这个Air Keyboard（空气键盘） 免费版是这个 如果你想氪金，不拦你用这个（18块） Air Keyboard allows you to use your iPad as a wireless keyboard and touch pad for your PC or Mac. Features available in the Pro version of the app: • 9 built-in keyboard layouts. Including regular keyboard, iPad soft keyboard, Media Player, Photoshop, shooter game, AZERTY and Cyrillic layouts. • Fully customizable keyboard layout designer. It allows you to create your own layout, place buttons as you want, set their appearance and bind keys. You can also download images for your buttons from Internet or local Photo Library. Layouts can be exported and imported via iTunes. • Key and event sequences. You can create a sequence containing key press, mouse movement, delay or scroll event and then bind the sequence to a button. This can simplify working with complex software. • Touch pad with multi-touch. Scroll gesture is supported on all systems. Multitouch is available for Windows 8+. This free Lite version has limited functionality. How can you use Air Keyboard? There are some ideas: • Use it for presentations • Play games sitting in a comfortable position • Control your home cinema distantly when resting on your sofa • Simplify using complex programs by creating special layouts and emulating shortcut sequences To use this app you have to install a server program on your computer. Get it for free at www.airkeyboardapp.com. Before you use this app, we recommend you to read the FAQ section on our website: www.airkeyboardapp.com/faq 来自App Store Air键盘允许您使用iPad作为无线键盘和PC或Mac的触摸板。 Pro版应用程序提供的功能： •9个内置键盘布局。 包括普通键盘、iPad软键盘、媒体播放器、Photoshop、shooter game、AZERTY和Cyrillic布局。 •完全可定制的键盘布局设计器。 它允许您创建自己的布局、根据需要放置按钮、设置其外观和绑定键。您还可以从Internet或本地照片库下载按钮的图像。布局可以通过iTunes导出和导入。 •键和事件序列。 您可以创建包含按键、鼠标移动、延迟或滚动事件的序列，然后将该序列绑定到按钮。这可以简化复杂软件的工作。 •多点触控的触摸板。 所有系统都支持滚动手势。 多点触控可用于Windows 8+。 这个免费的Lite版本功能有限。 如何使用气动键盘？有一些想法： •用于演示 •坐在舒适的位置上玩游戏 •在沙发上休息时，远距离控制家庭影院 •通过创建特殊布局和模拟快捷顺序简化复杂程序的使用 要使用此应用程序，您必须在计算机上安装服务器程序。 在www.airkeyboardapp.com上免费获取。 在使用此应用程序之前，我们建议您阅读我们网站上的常见问题部分：www.airkeyboardapp.com/FAQ 来自百度翻译 废话不多说，上图 这是最标准的界面，挺好看的。我是用这个，用iPad Pro会很舒服，但是不巧我不是iPad Pro。😭😭😭 这个使用的是iPad自带的键盘，这个不太好用。 这个是需要付费的一个键盘布局，高仿MacBook的键盘，但是姚要付钱，算了。 这是一个打游戏用的键盘，好用归好用，付钱，算了。 这是一个媒体控制键盘，付钱，哎。。。 这个软件也支持绑定PS，但是还是要付钱，而且也没搞到图，…… 高级一点 这个软件有个模式是当触摸板，不过要付钱，但是这个可以用一个小技巧来**掉。 就是使用我屏幕上的这个图标进行缩放，不需要软件。 先找到设置里的通用，点辅助功能 找到缩放的选项卡 建议大家打开“控制器”，“智能键入”这两个标签页，这样就可以放大到触摸板的那块屏幕，调整一下灵敏度，这样就OK了。 后记 虽然好像不付费的功能有点少，不过我体验下来还是够了的，这款软件比市面上的很多的软件都良心，所以推荐给大家。 ","link":"https://hesy-zhoulijie.github.io/post/airkeyboard/"},{"title":"12 张卡片，在 Windows 上带回 macOS 的特性","content":" 12 张卡片，在 Windows 上带回 macOS 的特性 在离开 macOS 这段时间，每天在家依赖 Windows To Go 为生，感到日常工作流程在四处冒烟。这才发现 macOS 的有些特性就如同空气一样，虽然毫无存在感，却不可缺失。 关于「如何在 Windows 中实现 macOS 的 xxx」，随便上网一搜就可以搜出很多结果，然而这些当中很多都是「为了实现而实现」，未能真正带回 macOS 散落在系统各处的便捷功能。另一方面，正因为有些功能的存在感低，所以自己在平时使用的时候也未必就留意，只有当想用到这个功能却发现没有的时候才会想起来。 macOS 与 Windows 的差异，有些是功能层面的差异，还有一些就是操作系统理念层面的东西了，深究下去难免会犯一些形而上的错误。从实事求是的角度出发，我还是很希望能够在 Windows 上复现一些 macOS 的优秀特性或理念的，好在能有所成，为之记。 Spotlight Windows 上的启动器说多也多，强大的也很强大，但是我对自定义配置感到力不从心。Listary 是一个非常好用的全局搜索工具，学习成本也很低，双击 Ctrl 键就可以在屏幕中央弹出搜索框，不用再进行太多的配置。 双击 Ctrl 键 值得一提的是，Listary 的这两个功能也让我印象深刻： 平时在执行应用的「打开…」操作后，定位的往往是默认的路径，用它可以自动定位至「文件资源管理器正在浏览的路径」。 在文件资源管理器中搜索文件时，忘掉右上角的搜索栏吧，甚至双击 Ctrl 的步骤也可以省略，直接打字即可，Listary 会被自动唤出，并且显示全盘的文件搜索结果。 自动定位至「文件资源管理器正在浏览的路径」 诚然，Listary 还有很多优秀的功能，但是对于我这样一个非计算机出身的「麻瓜」来说，光是描述清楚这些功能就得费老鼻子劲，还不一定讲得明白，更别说试着去用了。目前 Listary 对我而言就是一款简简单单的「Windows 上的 Spotlight」。 程序坞 RocketDock 自带的模板丑出天际，但是好在自定义简单，随手改改纯色背景就很耐看了。可以把 dock 固定在桌面，然后往上面添加应用、目录、分隔符等等。此外，「鼠标经过放大」、「移到废纸篓」等特性也都一应俱全，甚至连「最小化窗口到 Dock」、「高亮正在运行的程序」等等细节都可以复现。 「控制面板」的理念和 macOS 的「系统偏好设置」很相似，我也把它放在了 Dock 上。 鼠标经过放大 快速查看 「空格预览」同样是 macOS 最为人津津乐道的几大特性之一，QuickLook 很好地复现了这一点。和 macOS 一样，它也支持安装增强插件。好用就完事了，不多赘述。 触发角 触发角也是很不错的功能，实现起来难度也不大，尝试了好几款之后，最终确定了开源、轻量、好看的 WinXCorners。除了常规功能，它也支持触发指令的自定义。 自定义触发指令 剪贴板共享 这款应用。美中不足的地方在于，这样的剪贴板共享只能共享文字，图片必须作为文件来发送，这一点还是没有 Handoff 来得完善，即便如此，它也极大地提升了我的效率。 截图和录屏 说完文字，来说图片和视频，我把截图、录屏、录制动图这三点放一块说。macOS 虽然自带了截图录屏的功能，但是很多人还是会寻求第三方应用。 截图 Snipaste 是双平台最广为人知的第三方截图工具之一，界面清晰、功能全面，可以一站式满足标注、打码、贴图等多种需求。 录屏 ShareX 是一个专注于上传和分享的、附加功能非常丰富的工具包。我用到的是仅仅是它基于 ffmpeg 的录屏功能。 其实用它就可以完成截图、录屏、上传的一条龙工作流，并且支持的上传目的地非常丰富，囊括了各大相册、网盘、分享平台等等。 ShareX 的功能 上传目的地非常丰富 录制动图 在尝试了多个录制 Gif 的应用之后，参考 选择了 LICEcap，重在方便，选好帧率、窗口一拉，就可以开始录，生成的文件也非常小。美中不足的地方在于，录制的窗口无法固定长宽比例，如果想保证 4:3、16:9 等画面，只能通过手动修改像素值来实现。而且无法一键操作，录屏的窗口处于打开状态时有些碍手碍脚。 用所选项目新建文件夹 将 Files2Folder 下载下来后，简简单单用管理员权限运行一下即可。使用时右键上下文菜单就会出现一行 Files 2 Folder，点击即可实现「用所选项目新建文件夹」的功能。 用所选项目新建文件夹 双击压缩文件来解压 在 macOS 中，双击压缩文件可以自动解压，而在 Windows 中则不会。已经 2020 年，相信应该有越来越多的人放弃了 7Zip 甚至更老的 WinRar，转而使用 Bandizip。不过 Bandizip 有一项很方便的小功能值得一试： 经过如图设置后，双击压缩包即可自动解压缩，并在新窗口中弹出解压缩后的目录，非常方便。 在桌面显示驱动器的快捷方式 「在桌面显示驱动器的快捷方式」是 macOS 中一个不起眼的小特性，可以用 Desktop Media 实现。在插入 U 盘或移动硬盘之后，会在桌面出现它的图标。本地硬盘的图标默认也会显示，可以手动隐藏。 包管理器 与 Homebrew 一样，Windows 上也有可用的包管理器：Chocolatey。这是我在偶然的情况下得知的，虽然自己不一定用得上，但是不妨碍我把它拿出来分享一下。它可以用来统一安装和管理应用，类似于类 Unix 系统中的 yum 和 APT。 其他特性 除了上述的几个之外，还有许多特性暂时没有去尝试。 Launchpad：Windows 的开始菜单与之类似，感觉再大费周章去模仿就是「得其形而忘其意」了，故放弃。 标签：「标签」是 macOS 的文件管理理念区别于 Windows 的显著特点，要在 Windows 上实现这种无米之炊并不是太容易。 此外 FileMeta 可以通过修改文件元数据的方式，将标签作为一个子项打入文件的元数据中，这种方法基于的是 NTFS 文件系统的特性，也就是说离开了 NTFS 硬盘，标签信息就会丢失。 然而毕竟前文说过，WTG 是我的临时替代品，没有存放太多文件，也就没再在标签上大费周章，故放弃。 Mission Control：这个功能还是非常想实现的，毕竟 Windows 的任务视图比起它来还是差点意思，窗口大小一样，而且都很小，大块的位置留给了「近期文件」。不过很遗憾，并没有找到合适的方案。 文件历史记录：这项功能并非 macOS 独占，Windows 也是有的。不过就我身边而言，连知道它的人都很少，更别说用了。这项功能在「控制面板」中，需要注意的是，备份驱动器和文件所在的驱动器不能相同，否则就无法继续。当然，在局域网已经很发达的 2020 年，也可以考虑用网络驱动器来实现，这我就不去尝试了。 备份驱动器和文件所在的驱动器不能相同 这里由于时间关系，我就不展开讲了，感兴趣的同学可以下课之后自己试一试。 批量修改文件名：macOS 将其整合进了系统功能，Windows 上如果要去实现，就是「用特定应用满足特定需求」的话题了，不在本文讨论的范围之内。不过方案也是有的，我一直使用 AdvancedRenamer，谁用谁说好。 可能还有其他被我忽略的特性，欢迎补充。 ","link":"https://hesy-zhoulijie.github.io/post/win-mac/"},{"title":"像 Chrome 一样给 Word 装上插件，让它用起来更顺手","content":" 像 Chrome 一样给 Word 装上插件，让它用起来更顺手 Microsoft Word 是一个高效的排版软件。Word 原生就自带了我们大多数人都用不过来的基础功能，但是总会有一些小功能，强大如 Word 的软件却没有集成。这时候，一个插件或许就能直接解决我们的燃眉之急。 Word 等 Office 全家桶系列软件的「插件」叫做「加载项」，能够为我们直接提供 Word 并没有集成的功能。下面这篇文章，我来介绍推荐一些实用的 Word 插件。 **注：**下面介绍内容在 Windows 下编写，Office 365 版本 1904 的 Word。macOS 的 Office 全家桶同样支持安装插件，原理相同。 插件安装 在开始推荐插件之前，如果你从来都没有为 Office 应用安装过插件，或许你都不知道在哪里搜索下载它们。我以 Office 365 中的 Word 为例子，先来简单说说怎么安装实用 Word 插件。 Word 本身自带了插件的安装入口，我们在「插入 → 加载项」处就可以看到「获取加载项」和「我的加载项」这两个按钮。 Word 内置的加载项商店 在 Office 应用中下载的插件会随你登录 Office 时使用的微软账户同步，一处下载，处处安装。点击「获取加载项」，我们就可以看到 Office 插件商店，在这里我们就可以直接搜索下文推荐的插件，并直接安装到本机 Office 应用之中。 Office 加载项商店 不过，经过我实测，这里的插件推荐很过时，编辑精选第一位的插件最后一次更新时间竟然是 2011 年。😓 因此，除了直接在 Office 自带商店浏览推荐插件，在 Microsoft AppSource 市场也可以查看下载推荐插件。这里的插件更多的是面向企业市场，但是我们同样也可以参考安装。 接下来，我来推荐下面这 6 个专为 Word 开发的插件。👍 Emoji Keyboard 第一个推荐的插件就是这个专门用于输入 Emoji 表情的插件了。可能你会说「嗯？Windows 1809 不是都已经自带了 Emoji 输入面板了吗？」，但是这个插件确实有所用处，因为它不仅会为我们提供插入 Emoji 字符的便捷方式，还提供了一套高清 Emoji One 系列的图片 Emoji。🤭 Emoji Keyboard 由于 Emoji One（现在改名字叫做 JoyPixels 了）的 Emoji 表情都是由 Creative Commons License (CC-BY 4.0) 许可标准发放的，因此我们可以在自己的个人作品中自由使用。具体的著作权许可请直接参考：JoyPixels Licenses 我们可以在 AppSource - Emoji Keyboard 处查看下载 Emoji Keyboard 这个 Word（也支持 PowerPoint）插件，在「加载项商店」也可以搜索直接下载。 Wikipedia 插入文献、网页的引用从来都是 Word 的必备功能。Wikipedia 这个插件让我们不必另外打开一个浏览器去维基百科上面搜索相关的内容，直接在 Word 里面搜索就可以。 Wikipedia 同时，在 Wikipedia 插件的页面里面，我们选中一段文字，上面就会出现插入当前文档的加号按钮。点击加号，这段文字就可以直接插入到我们当前的 Word 文档中。并且 Wikipedia 插件还会直接在下面添加相应的引用链接，只需要稍微调整格式就直接完成维基百科内容的引用。非常方便。 我们可以在 AppSource - Wikipedia 这里下载到 Wikipedia 插件，同样也可以在「加载项商店」处下载安装。 Translator Translator Translator 这款由微软官方出品的 Translator 插件，能够帮我们直接在 Word 里面将文章内容进行翻译。Translator 使用的是微软的翻译 API，能够支持将文档中选中的内容直接翻译替换，无论是在阅读非中文 Word 文档，还是自己撰写英语文章，Translator 都大大方便、简化了我们到浏览器里面复制翻译结果回来的复杂流程。 我们可以在 AppSource - Translator 这里下载 Translator 插件，「加载项商店」里面搜索也可以下载得到。 Font Finder Font Finder Font Finder 也是由微软官方发布的字体插件。这个插件直接集成了很多有趣的英文字体，分为经典、手写、清晰、华丽等七类，供我们选择。就算我们电脑本身并没有安装这个字体，Font Finder 插件也可以帮助我们直接使用这个字体。不过，遗憾的是，Font Finder 里面集成的字体几乎都是英文字体。也就是说，很多华丽的中文字体，我们并没有途径直接用 Font Finder 使用。 我们可以在 AppSource - Font Finder 这里直接下载 Font Finder 这个插件，也可以在「加载项商店」里面搜索下载。 MyScript Math 作为 Office 应用奖 2017 中最佳用户体验奖的第二名，MyScript Math 这个插件和 iOS、Android 上面同一家公司 MyScript 出品的 MyScript Calculator 使用体验一样顺滑，手写公式自动转换识别率非常高，堪称完美。无论是普通的变量、运算符还是高级的积分、求和等复杂公式，MyScript Math 这个插件都能胜任。 MyScript Math 自动识别手写公式 我们利用 MyScript Math 插件手写的公式，识别成为公式格式的文本之后就可以直接插入到 Word 文档之中，根本不用再去查阅复杂的 LaTeX 使用方法，简洁方便。 我们可以在 AppSource - MyScript Math 这里下载 MyScript Math 这个插件，「加载项商店」也可以搜索到。 Grammarly Grammarly 是一家专门对文档、论文等学术文章进行语法、语义和词法检查的公司。其对英语文献的语法检查效果可以说是精准、到位，比 Word 原生的语法检查好上不少。即使是免费版本的 Grammarly 账户，都能够及时准确的为你找到文章中的语法错误。 Grammarly Grammarly 也肯定是考虑到，使用 Word 编写排版论文文献的同学太多太多，于是也为 Word 开发了 Grammarly 的集成插件。这个插件让我们在写英文文章的过程不再焦虑语法问题，其自动修错功能不仅能够为你错误的地方下方标红，还能够告诉你错误的具体原因，以及建议的修改方法。而上面这些仅仅是 Grammarly 的免费账户就有的功能，付费的 Grammarly 账户甚至还可以帮助你将文章更深程度的润色，寻找更好的表述方式、同义词、使用语法等等。可以说是撰写英文文章的神器。 我们可以在 Grammarly 的官网 找到 Grammarly 为 Office 制作的插件安装程序。和上面推荐的五个插件不同的是，Grammarly 是独立的安装程序，因此需要单独安装才可以正常使用。 小结 虽然 Word 对于我们大多数人已经足够强大，其中几乎半数的功能我们使用期间都可能用不到，但是 Office 的插件功能还是通过很多创新性的内容，以及利用 Web 技术提供的优秀跨平台功能，帮助我们提高生产力和工作效率。 只是，太多太多的 Office 市场中的推荐插件都年久失修，而 Office 插件商店的推荐位置又没有很好地运营，导致大量优秀的插件被埋没。我经过大量的查找和尝试，才找到这六个为 Word 开发的插件推荐给大家。希望通过这篇文章的推荐，你使用 Word 的体验能更上一层楼。感谢阅读。🙌 ","link":"https://hesy-zhoulijie.github.io/post/word-plugin/"},{"title":"用好这些隐藏「小开关」，让 Chrome 浏览器更好用","content":" 用好这些隐藏「小开关」，让 Chrome 浏览器更好用 相比移动端的 Chrome 浏览器，功能性能更强更全面的桌面端 Chrome 可能是你我每天使用频次最多的桌面软件。多端数据同步、实用的扩展插件都让其成为电脑上的「超级应用」。近乎无限制的桌面平台也让其可以在第一时间运用起新的功能和技术，这也是限制重重的移动端 Chrome 所无法比拟的。 当然因为桌面端 Chrome 的广泛使用性，新功能的推出和运用反而会更为谨慎。如果想要尝鲜新功能一样是通过 Feature flags —— 当然比起移动端，桌面端的新功能主要针对的键鼠操作，和移动端有相当大的区别。 尝鲜新功能，善用 Chrome flags Chrome 之所以被认为是「超级应用」，很大程度上在于起功能增添和更新上像极了操作系统，新功能会首先出现在 Dev 版、然后经过 Beta 测试后，最后推送到稳定通道中。而新开发的功能则被隐藏在 Chrome flags —— 作为新功能的试验田，通过开启特定的 flags 来在稳定版中尝鲜新功能，即可以尝鲜也避免了可能的不稳定风险，下面我们挑选了一些稳定性尚可且比较实用的 flags， 通过开启对应的开关来让 电脑版的 Chrome 变得更好用。 注：本文 Chrome 版本为稳定通道 v78，电脑系统为 Windows 10 v1909 开启并行下载功能 移动端 Chrome 考虑到带宽和设备性能问题，只允许单进程下载其实并无不妥，而桌面端至今依旧默认单进程下载似乎就有点说不过去了，所以相比移动端，在桌面端开启并行下载功能要更为迫切一些。 开启方法和移动端一样， 在 Chrome flags 上搜索「Parallel downloading」来开启 Chrome 的并行下载功能，你可以尝试下大个文件以及多个文件，你会发现速度会提高那么一些。当然如果有条件的话，选择第三方下载工具进行资源下载反而更为合适。 开启方法： chrome://flags/#enable-parallel-downloading 给标签页进行分组 多标签页浏览器有时也会给我们带来烦恼——我们会不自觉的打开 n 多标签页，时间一长就会忘记哪些标签页是有关联的，比如像我就经常遇到已经打开了某个标签页但最后又重复打开的，其实对标签页分组就可以妥善解决这些问题。 这个很实用的功能同样也是默认隐藏，需要在 Chrome Flags 中搜索「Tab Groups」开启，之后将开启自动分组功能。自动分组功能将根据你的打开新标签页的方式，比如从少数派中打开的新内容页面将会自动添加到一个组中，这时会在标签页前面出现一个「组标记点」。 你还可以手动创建新的组或者将当前标签页加入组中，通过拖拽的标签页将起放在「组标记点」后面就可以添加到当前组，而移除则只需要将标签页从组中拖拽出即可，而为了标记的更清楚，点击组的标记点还可以更改颜色，也可以为组进行命名让其更明显。 开启方式： chrome://flags/#tab-groups 桌面端开启阅读模式 无论是 Firefox 还是旧版本的 Edge 浏览器，都内置有阅读模式，这些功能并非是多此一举，而是可以极大的提高内容阅读体验，去除广告、无关的框架样式等干扰性元素，内容重新排版之后方便进一步的深入阅读，即便不使用稍后读服务也能做到类似的信息阅读体验。 奇怪的是这个功能在桌面端的 Chrome 中依旧被隐藏在 flag 中，而开启方式是在 Chrome Flags 中找到「Enable Reader Mode 」来开启这个功能，打开之后重启浏览器，在地址栏的最右侧会出现一个新的图标，点击之后就会直接将当前网页转换成阅读模式，不过比起移动端功能丰富的设置项，桌面端的阅读模式要简陋很多，也无法对主题、字体和字号大小进行调整。 开启方式： chrome://flags/#enable-reader-mode 让网页内容强制显示为深色主题 macOS Mojave 开始支持系统深色主题的同时，Safari 也加入了一个新的 API，允许已经加入深色主题的网站跟随系统调整深色主题，只不过目前绝大多数的网站并不支持这一特性，而在 Chrome 中其实也支持类似功能，只不过该选项并非是默认开启同样需要通过在 Chrome flags 中手动开启。 在 Chrome Flags 中搜索「Force Dark Mode」就可以看到设置选项，并且提供了相当多的显示效果选择，选择「Enable」重启后就可以看到强制开启后的基本效果，对于没有提供网页深色主题的网站，强制开启可以认为是原先网页配色在色环上对应的反色，所以看上去的展示效果比较一般，并且不同的网站的深色主题展示效果不佳，有些网站甚至完全无法用，只能用来进行一定程度的尝鲜。 开启方式： chrome://flags/#enable-force-dark 开启全局媒体播放控制 播放在线多媒体时，如果需要暂停，快进等操作都要进入到标签页中进行调整，有时候标签页开的多，实在没法立即定位到播放页面就会很麻烦。有一个全局媒体播放控制可以简化这些步骤，这样就不用打开对应的标签页也可进行全局控制。 开启方法也很简单，同样是在 Chrome Flags 中搜索「 Global Media Controls 」找到之后选择「Enable」重启浏览器，这时候你打开一个视频播放页面并播放视频，同时在工具栏中就会出现一个多媒体按钮，点击就可以看到一个媒体播放选项卡，无需打开对应标签页就可以控制多媒体内容播放。 开启方式： chrome://flags/#global-media-controls 鼠标悬停标签页展示网页预览图 开的标签页多了之后会逐步挤占标签页的标题文本信息，想要知道里面网页内容就只能切换到该标签页查看，那么如何不切换到当前标签页就能看到到网页里面的大致内容呢？这项早已出现在经典版 Edge 浏览器上的功能在 Chrome 竟然也是隐藏功能，开启方式当然还是在 Chrome Flag —— 搜素「Tab Hover Card Images」选择开启就可以看到效果了。 开启之后当鼠标悬停在标签页时将可以看到网页内容的预览窗口了，不用切换标签页就可以看到内容可以说更为方便一些，不过这项功能对系统性能有一定的要求，如果想要更好的浏览体验可以酌情开启。 开启方式： chrome://flags/#tab-hover-card-images 结语 相比移动端的 Chrome 浏览器，桌面端的 Chrome 浏览器的新功能更多的增强多标签页的体验上，更大的浏览面积以及基于键鼠的交互操作在一定程度上可以更为精准的控制，也更容易凸显其作为生产力工具的作用，通过在稳定版通道的 Chrome 开启 flags 功能可以提前尝试一些未来出现的功能，当然是否适合你就见仁见智了。同样如果你发现了有趣实用的 flags，欢迎在问下评论分享给我们。 请绑定手机号码 取消 前往绑定 ","link":"https://hesy-zhoulijie.github.io/post/chrome-flags/"},{"title":"查天气、搜歌词、监控系统状态…… 用这些 App 把 Mac 菜单栏变成万能工具箱","content":" 查天气、搜歌词、监控系统状态…… 用这些 App 把 Mac 菜单栏变成万能工具箱 为了彰显存在感，各路 Mac 应用都喜欢在菜单栏上安置一个图标：其中有的只是用来召唤主界面，也有一些应用发掘了更多用途，真正利用好了 macOS 菜单栏这块「宝地」。 今天，就让我们来认识一下 21 款各具特色的工具 App，它们能够让寸土寸金的菜单栏物尽其用，打造成专属于你的万能工具箱。 One Switch 桌面文件总显得凌乱无序、临时离开又想保护隐私…… 这些琐碎需求，One Switch 帮你一站解决。它整合了隐藏桌面图标、切换黑暗模式、始终保持亮屏、快速进入屏保和切换 AirPods 5 项实用功能，都可以一键开启。开发者称，未来还会加入更多新特性，敬请期待。 你可以在 官网 购买 One Switch，国内定价为 30 元。 Amphetamine 一段时间未操作后，Mac 就会进入休眠状态，但如果你正在演示 Keynote 或观看视频，或许希望给电脑打针「兴奋剂」，Amphetamine 就是个不错的选择。它不仅可以临时阻止 Mac 休眠，还提供了丰富的自定义选项，可以在指定时间段、运行特定 App、连接至指定 WiFi 等情况下自动启用。 你可以在 App Store 免费获取 Amphetamine。 NightOwl 尽管 One Switch 已经提供了切换黑暗模式的选项，但现在流行的是依据时间自动切换主题。而 NightOwl 这款小工具不仅允许你计划时间段，还能通过位置信息在日出日落时自动切换模式。此外，你还可以让指定 App 始终保持浅色外观，使用更舒心。 你可以在 官网 免费获取 NightOwl。 Infinity Dashboard 在这个信息过载的时代，我们每天都需要了解各方面动态：天气、日历、股票、汇率、社交网络……Infinity Dashboard 就将这些信息整合到了一起，只需点击菜单栏图标，就能尽知天下事。 你可以在 官网 以 9.99 美元的价格购买 Infinity Dashboard。 关联阅读：看日历、查汇率、等商品降价……只需扫一眼 Mac 菜单栏：Infinity Dashboard RunCat 在菜单栏显示实时 CPU 占用率的 App 你或许见得多了，但像 RunCat 这么有趣的可谓独一份。它将 CPU 负荷浓缩为 GIF 动图，电脑越卡，菜单栏的猫咪就跑得越快，纾解心中压力。除了默认的🐱外，RunCat 还提供了🦆、🐴、🐧、🐙等多种主题，满足各种喜好。 你可以在 App Store 免费获取 RunCat，🐶、🐸、🐲、🎄等主题及自定义皮肤功能需要付费解锁。 网速 &amp; 电池 顾名思义，网速 &amp; 电池是一款可以显示实时网速、存储占用及电池状态的小工具。它提供了多种显示方式，并适配了 macOS Mojave 的黑暗模式。除了菜单栏外，网速 &amp; 电池还支持通知中心小组件和置顶悬浮窗口，助你快速了解系统状态。 你可以在 App Store 以 12 元的价格购买网速 &amp; 电池。 iStat Menus 6 iStat Menus 6 同样是一款系统状态监控工具，它涵盖了 CPU、GPU、内存、磁盘、网络、电池、传感器等各种模块，信息详尽，并支持自由定制。你还可以添加触发器，在电池电量不足、内存占用过高等情况下收到推送通知。 你可以在 官网 以 11.99 美元的价格购买 iStat Menus 6，应用同时包含在 Setapp 订阅中。 关联阅读：不仅系统监控要做得更出色，iStat Menus 6 还能让你在状态栏看天气了 Itsycal macOS 原生的菜单栏时钟着实有些简陋，不仅无法查看日程，连今天是几月几号都无从知晓。而 Itsycal 就是个不错的补充，它允许你在菜单栏查看日历月视图及接下来的事项安排，并自定义日期格式、高亮等。 你可以在 官网 免费获取 Itsycal。 关联阅读：Fantastical 太贵了？试试免费的菜单栏日历工具：Itsycal PicGo PicGo 是一款免费开源的跨平台图床工具，可以通过快捷键或菜单栏图标快速上传剪贴板内图片。它预置了微博、SM.MS、GitHub、阿里云、腾讯云等 8 家主流图床服务，并可以通过插件扩展更多玩法。 你可以在 GitHub 免费获取 PicGo 的 macOS、Windows 和 Linux 版本。 关联阅读：图床「神器」PicGo v2.0更新，插件系统终于来了 Sip 无论是设计海报、UI 界面还是其它作品，颜色搭配都是件重头戏。不过，要想调配出与主题相契合的色彩组合并不是那么简单，而 Sip 就能从任意界面提取颜色，并生成色卡，还支持一键复制为多种代码格式。 你可以在 官网 以 10 美元的价格购买 Sip，应用同时包含在 Setapp 订阅中。 关联阅读：设计师的好帮手，萃取生活里的缤纷色彩：Sip Color Pomo Timer Pomo Timer 是一款常驻在菜单栏上的番茄钟工具，其 UI 简洁美观，支持设定番茄时长、计划任务、通知样式等，可以帮助你轻松创建和管理番茄定时器。如果你不喜欢默认番茄图片，还可以自行替换为其它图像，更有乐趣。 你可以在 App Store 免费获取 Pomo Timer，自定义番茄图片功能需要内购解锁。 Mate Translate Mate Translate 是一款菜单栏翻译工具，支持自动检测源语言、自动翻译剪贴板、快捷键呼出及音标、拼音显示等。由于其采用 Google 作为底层翻译引擎，保证了翻译的准确性，同时比网页 Google 翻译更方便快捷，随用随取。 你可以在 App Store 以 198 元的价格购买 Mate Translate，并在 官网 获取其它平台版本，应用同时包含在 Setapp 订阅中。 ToothFairy 尽管 AirPods 支持在苹果全家桶间无缝切换，但在没有状态指示的 Mac 上，依然可能出现外放响彻整个图书馆的尴尬。有了 ToothFairy，你就可以在菜单栏图标上看到所有蓝牙设备的连接状态及剩余电量，并通过点击或快捷键快速切换。 你可以在 App Store 以 18 元的价格购买 ToothFairy，应用同时包含在 Setapp 订阅中。 关联阅读：如果你在 Mac 上用 AirPods 和 BeatsX，ToothFairy 能帮你一键切换 LyricsX 如果你正在使用 Apple Music 或 Spotify，或许会怀念国内音乐 App 的歌词显示及滚动功能。而 LyricsX 就能自动识别 iTunes、Spotify 和 Vox 上播放的歌曲名称，并匹配对应歌词，在菜单栏、悬浮窗或独立窗口中动态显示。 你可以在 App Store 和 GitHub 免费获取 LyricsX。 休息一下 我们都知道，长时间面对电脑屏幕对视力损害极大，但却很难管住自己；若是使用番茄钟，5 分钟的休息时间又难免打断工作状态。而休息一下则利用 20-20-20 视力保护原则，每过 20 分钟提醒你休息 20 秒，并将视线转移至 20 英尺（约 6 米）外的物体上，既纾解眼部压力，又不会因时间过长而影响正常工作。 你可以在 Mac App Store 免费获取休息一下。 Noizio 终日生活在狭小的格子间中，你可能会向往大自然的怀抱。而 Noizio 这款白噪音应用，就能播放秋雨、雷鸣、柴火、海浪、溪流等多种声音，并支持混合音效配置，舒缓身心，释放压力。 你可以在 App Store 以 30 元的价格购买 Noizio，应用同时包含在 Setapp 订阅中。 Irvue 看腻了一成不变的桌面，又无暇寻觅新的壁纸，有了 Irvue，这些都不是问题。它可以自动获取 Unsplash 上的精选照片并定期更新，还提供了点赞、下载、加入黑名单等操作，让你每天都有新惊喜。 你可以在 App Store 免费获取 Irvue。 关联阅读：你只需要欣赏桌面，把换壁纸的事交给 Irvue 就好了 Kaomoji Lover Kaomoji Lover 是一款常驻在菜单栏上的卖萌神器，它收集了超过 18000 个表达各种情绪的颜文字，只需点击菜单栏上的图标，就能轻松复制并插入任何你喜欢的表情，让聊天更有趣。 你可以在 App Store 下载 Kaomoji Lover，售价 ¥50。 HazeOver Mac 窗口一多，往往会忘记当前焦点是哪个，HazeOver 则可以为非活动窗口加上一层阴影，帮助你专注于当前工作。在偏好设置中，你还可以设置遮罩颜色、透明度及快捷键等，方便省心。 你可以在 App Store 以 68 元的价格购买 HazeOver，应用同时包含在 Setapp 订阅中。 Bartender 3 安装了上文介绍的 App 后，如何整理多到溢出的菜单栏图标又成了件烦心事，而 Bartender 3 就能帮助我们将用不到的图标藏起来。它的原理是给菜单栏加上一块「平行」区域，点击图标即可切换，眼不见心不烦。 你可以在 官网 以 15 美元的价格购买 Bartender 3，提供 4 周免费试用。 关联阅读：不仅要能藏，还要藏得优雅，Mac 菜单栏简化工具 Bartender 3 更新 Dozer Bartender 虽好，价格却略感人，完全免费的 Dozer 就是个不错的替代品。它的操作十分直观，只需按 ⌘Command 拖动菜单栏图标，将想隐藏的项目拖到两个标志点的左侧，点击后就会被收纳，再次点击即可展开，轻量简单。 你可以在 官网 免费获取 Dozer。 关联阅读：一个完全免费的 macOS 菜单栏工具，一拖一点就能轻松隐藏图标：Dozer 你还有哪些好用的 macOS 菜单栏工具想要与我们分享，欢迎在评论区告诉我们。 ","link":"https://hesy-zhoulijie.github.io/post/mac-taskbar/"},{"title":"Apple WWDC 2019","content":"Apple WWDC 2019 iPad 有了自己的系统，还有新 Mac Pro…… 昨晚发布会要点都在这了 北京时间今日凌晨 1 点，苹果在美国加州的圣何塞会展中心召开了一年一度的 WWDC 全球开发者大会。作为受邀媒体，少数派今年继续全程在美国现场报道本次开发者大会。在将近 2 个半小时的开幕演讲中，苹果发布了拥有全局深色模式的 iOS 13、全新独立系统的 iPadOS 以及 watchOS 6 和 tvOS 13。 作为 WWDC 的惯例，本次新系统的发布依旧是发布会的重点，不管是独立出去的 iPadOS 还是推出 Project Catalyst 的 macOS，对于消费者和开发者都是一件影响颇深的事件。与此同时，模块化的高性能 Mac Pro 终于也带着全新的设计回归，而支持 Retina 6K 和 Pro Display XDR 的专业显示器也赚足了眼球。 iOS 13 作为本次 WWDC 的重头戏，iOS 13 闪亮登场。继去年深色模式登陆 macOS 之后，iPhone 和 iPad 也终于拥有了自己的深色模式，并且为照片应用新增了强大的浏览和编辑功能、提供以 Apple ID 登录应用或网站的选项以及可以在地图中获得更多的信息。 除了新增功能，iOS 13 在性能优化上也有出色的表现，例如应用启动速度提升了两倍、应用更新速度也有提升等。 对眼睛更友好的深色模式 千呼万唤始出来，传了多年的 iOS 深色模式终于发布了。这次发布的 iOS 深色模式和 macOS 上的深色模式一样都是系统级的，所有的界面以及自带应用都已经适配了深色的配色方案，在低光情况下有很好的表现，屏幕看起来让眼睛更加舒服。 除了系统自带应用，苹果也向第三方应用的开发者开放了接口，开发者们也可以方便地让自己的应用适配 iOS 的深色模式。除了手动启用，iOS 的深色模式也可以通过设定固定的时间或者依据当地的日出日落时间来自动切换。 更加强大的照片编辑工具 有机器学习加持之后，照片应用获得了更加强大的功能。首先，照片应用可以通过突出最好的照片、自动隐藏杂乱或者重复的照片来更好地展示过去的一天、一月或一年中重要的事件，巧妙地结合照片和视频，让使用者在浏览、发现和重温最喜欢的回忆时变得更加容易。 其次，照片应用获得了丰富的编辑功能。只需轻轻一滑，你就可以轻松地调整照片的特效，通过原生的功能解决了调用第三方工具的繁琐，为摄影爱好者们提供了更多的创造可能性。除了照片，iOS 13 的照片应用还可以直接编辑视频，用户可以直接在其中旋转、裁剪和使用滤镜，方便了很多。 同时，人像模式新增了一个光线调节和一个 High-Key Mono 效果的选项，可以创造出更加好看的肖像照片。 便捷、私密的苹果账号登录 越来越多的网站需要我们使用手机、邮箱、社交账号等来注册和登录，不但不方便管理，而且极易泄露自己的隐私。 苹果这次推出了使用 Apple ID 登录的功能，轻松、简单地完成身份验证和登录网站。同时，为了保护使用者的隐私，苹果允许用户隐藏自己的邮箱地址，甚至可以自动生成一个随机的邮箱地址来替代。用户使用 Apple ID 来登录的时候，可以通过 Face ID 或者 Touch ID 来验证，加上双重验证，不但方便而且还确保了自己的隐私不会被泄漏。 全新的地图体验 为了让 iOS 用户获得更好的地图使用体验，苹果在驱车 400 万英里收集数据后开始重构地图应用。在 iOS 13 的全新地图应用中，用户可以获取到更广泛的道路覆盖范围、更好的行人数据、更精确的地址和更详细的土地覆盖，并将在近两年推广到更多的国家和地区。 iOS 13 的地图应用新增了街景的功能，所有的图像由全新的基础地图和高分辨率的 3D 摄影构成，帮助环顾功能提供了一个平滑无缝过渡的街景浏览体验。除此之外，地图应用还可以轻松分享最喜欢的餐厅、旅游目的地或者与朋友购物的地方，或者导航到常去的目的地，如家、办公地点、健身房或学校等。 其他值得一提的功能： 提醒事项应用重做，UI 设计交互完全改变，新增的快速工具栏可以方便地添加时间、日期、地点、旗标以及附件； 信息应用可以自动共享用户的姓名和照片、Memoji 或者 Animoji，同时 Memoji 可以制作成贴纸在自带应用和第三方应用中使用； 借助 Neural TTS ，Siri 有了一个更加自然的声音，并且提供更加个性化的自动化推荐； AirPods 可以通过 Siri 来读取和回复信息； 语音控制可以让用户完全通过语音来控制 iPhone、iPad 和 Mac； 原生键盘提供了滑动输入的选项。 iOS 13 升级仅支持 iPhone 6S 及之后推出的手机，以及 iPod touch 7。 iPadOS 在第一代 iPad Pro 发布将近四年之后，Apple 终于正式将 iPad 作为一个独立的平台与 iOS 独立开来，进一步强调了 iPad 的生产力属性，并在本次为它带来了许多独占功能。 多任务处理 本次 iPadOS 最大的更新在于对多任务处理的巨大改进。首先，Slide Over 从一个单纯的悬浮窗口变为了一个拥有完整功能的窗口模式。在本次更新后，你可以通过滑动应用窗口顶部的 Home Indicator 来切换应用，相当于在原来的多任务中心之外又嵌套了一个专属于 Slide Over 的多任务中心。 关闭 Slide Over 中的应用窗口也是一样的操作，只需将应用卡片上滑退出即可。若想将 Slide Over 中的应用设为全屏应用，则需将应用窗口拖拽至屏幕的顶部。 与此同时，iPad 终于支持了同一应用的分屏模式，而不再像之前只能使用两个应用同屏。 除了单纯的分屏模式，同一应用还可以同时在分屏模式和 Slide Over 模式下同时使用。如果你想查看同一应用的不同位置，你可以使用从 macOS 新引入的 App Exposé，只需点击它在 Dock 上的图标即可进入 App Exposé 视图。 除了拖拽窗口，现在直接拖拽链接、地址等信息也可以创建新的应用窗口，免去了先打开应用的麻烦。 主屏幕能摆更多图标了，还能直接看小组件 在 全新的 iPadOS 中，主屏现在可以放下更多的应用。另外，iPadOS 直接去掉了 iOS 上的负一屏，如果要在 iPadOS 上查看小组件，只需要通过右滑手势，就可以直接在主屏幕拉出控件，和主屏图标一起显示，利用小组件查看信息或者进行一些快捷操作会变得更加方便。 文件应用更像 Finder 了，Safari 新增下载管理器 作为一个主打生产力的平台，系统文件应用在 iPadOS 中更新自然不会让人意外。新版文件应用支持了最多达 3 栏的显示视图，你还可以直接在文件应用中预览文件的各项信息—比如类型、大小、修改时间、图片的分辨率等等—而不用打开文件。 iOS 12 中文件应用虽然能共享文件，但是没有支持文件夹共享功能，iPadOS 终于补上了这一功能。你可以直接在文件应用里将文件夹共享给别人、或者连接别人共享出来的文件夹。除了共享云端文件，iPadOS 支持将 U 盘、SD 卡等外部存储设备连上 iPad，直接读取里面的文件。 在文件管理方面，Safari 也有新动作：终于支持了下载管理器。管理下载文件也非常简单：在系统文件应用找到下载文件夹就可以了。 除了下载管理器，Safari 在网页浏览方面也有比较大的改进：iPadOS 会直接在 Safari 中展示桌面版网页，并对一些需要鼠标操作的元素进行了触控优化，让你可以获得足够优秀和流畅的桌面级网页浏览体验。 打字更方便了，也更快了 iPadOS 支持的 Floating Keyboard 浮动键盘能够让你通过双指捏合手势将键盘变为一个可拖动的悬浮窗口，如果你没有在用 Smart Keyboard 等外接蓝牙键盘设备，用双指捏合手势将键盘拖到左右手的任意一边打在效率应该会高不少。 除了双指捏合手势，iPad OS 还新增了三指捏合复制、张开粘贴文字以及三指左滑撤销手势，按照发布会上的说法就是，你再也不用摇晃大尺寸的 iPad 来撤销误输入的文字了。 此外，iPadOS 还支持了单指拖动选中指定文字、双击选中单词等实用手势，在输入效率方面的提升还是比较明显的。 其它值得关注的 iPadOS 特性： Apple Pencil 的响应延迟时间由 20ms 提升到了 9ms； Apple Pencil 工具栏支持拖拽移动位置，将 Apple Pencil 移到 iPad 屏幕角落会触发截图操作并自动弹出标注界面； 新增 Sidecar 功能，让你通过 Wi-Fi 将 iPad 作为 Mac 的第二显示屏； 在 iPadOS 上用 Face ID 解锁速度比 iOS 12 快了 30%； 与 iOS 同步支持 Voice Control、AirPods 共享、HomePod 上的 Handoff 音频传输等功能； 支持下载和管理字体。 iPadOS 更新仅支持 iPad Air 2 及之后推出的 iPad、iPad Pro 和 iPad mini。 macOS 10.15 今年苹果把 macOS 10.15 命名为 macOS Catalina。正如此前爆料所言，今年的 macOS 第一个主要的新变化便是将 iTunes 进行了拆分。三个全新的 App：音乐、播客和 TV 将取代 iTunes，而此前同步与备份 iOS 设备的功能在新版系统里则被集成到 Finder 中。 在机器学习的帮助下，新的播客应用拥有更强大的搜索功能。现在输入关键词后，应用将为你直接搜索音频内容中出现该关键词的播客。 新的 TV 应用则支持在 Mac 上播放 4K HDR 内容，此外还提供了杜比视界和杜比全景声的支持。 另外新版的提醒事项和照片应用也将同步登陆 macOS Catalina。 macOS Catalina 第二个主要的新功能是 Sidecar，它可以让你的 iPad 变身成为 Mac 的拓展屏幕。不仅如此，在新系统中你还可以把 iPad 当作 Mac 的手写板或绘图板来使用，用 Apple Pencil 直接在屏幕上画画和批注。该功能目前支持包括 Adobe Illustrator、Affinity Photo 和 Maya 在内的多款专业级应用。 去年苹果在 iOS 上推出了屏幕时间功能，让你可以了解和控制自己花费在 iOS 设备上的时间。今年 macOS Catalina 则把这项功能带到了 macOS 上。 苹果系统在辅助功能方面体验一直走在行业的前列。macOS Catalina 今年则在语音控制上更进一步，现在用户可以完全通过语音来控制使用 macOS，从打开应用、选择菜单功能再到输入文字，整个流程完全可以通过语音指令完成。 macOS Catalina 中还新增了一个名叫「查找」的新 App。它集成了 iOS 上查找 iPhone 和查找我的朋友两款应用的功能。此外它还新增了一个可以查找未联网 Mac 的功能。另外配有 T2 安全芯片的 Mac 还可以在新系统中增加启动锁。 苹果曾在去年介绍过帮助开发者将 iPad 应用快速迁移至 macOS 上的 Marzipan 项目，今年苹果将它正式命名为 Project Catalyst。苹果表示他们在过去的一年里做了大量的工作，来保证迁移项目能够得到更流畅的体验。发布会上苹果表示包括 Twitter、Jira 和 Gameloft 在内的多家第三方厂商正在参与这一项目，对自家的应用进行适配。 最后，设备支持方面，macOS Catalina 支持 2015 年及之后的 MacBook，2012 年及之后的 MacBook Air、MacBook Pro、Mac mini 和 iMac，2017 年及之后的 iMac Pro 以及 2013 年及之后的 Mac Pro。 watchOS 6 作为 watchOS 的第 6 个版本，watchOS 6 终于有了独立的 App Store 应用，这意味着你可以直接在 Apple Watch 上搜索、下载和运行应用，不再需要依赖 iPhone。Apple Watch 上的 App Store 支持语音和 Scribble 手写两种搜索应用的方式，你也可以在 Apple Watch 上直接查看 App Store 编辑的推荐或者来自用户的评价。 除了 App Store，watchOS 6 也将计算器、语音备忘录和有声书三款应用带到了 Apple Watch 上，其中计算器应用还支持了小费计算这样的实用功能。 其它值得关注的 watchOS 新特性有： 新增渐变色、大数字、模块化等多个新表盘样式。 新增运动记录趋势分析功能，watchOS 会根据你的运动情况给出调整建议，并同步在 iOS 中的「健身记录」应用中进行展示。 新增月经周期记录功能，支持月经、排卵期提醒等。 新增环境噪音检测功能，并会在当前环境噪音过大时进行提醒。 新增正点报时功能。 watchOS 支持包括 Apple Watch Series 1 在内之后的全部 Apple Watch 设备，不支持初代 Apple Watch。要想升级 watchOS 6，你需要有一台 iPhone 6s 或更新的 iOS 设备，并且确保 iPhone 升级到了 iOS 13 或者更新的系统版本。你可以在 Apple 官网查看 watchOS 6 的详细信息。 tvOS 13 tvOS 13 支持了多账号功能，并且会根据每位家庭成员的观影记录进行个性化推荐，Apple Music 还支持实时显示正在播放歌曲的歌词。 在游戏娱乐方面，tvOS 13 支持了 Xbox One 和 PS DualShock 两款游戏手柄，在 Apple TV 上玩游戏将能够获得更好的游戏体验。最后，Apple 还与 BBC Natural History 纪录片剧组合作，在 tvOS 13 上带来了一系列 HDR 高清海底壁纸，让你在家就能拥有身临其境的海底世界体验。 tvOS 13 支持目前在售的 Apple TV 4K 和 Apple TV HD 两款型号设备，你可以在 tvOS 官网查看 tvOS 13 的新特性。 iOS 13、iPadOS、macOS Catalina、tvOS 13 和 watchOS 6 的 Beta 测试版本目前已经开放给开发者进行下载，7 月份会对所有人开放公开测试版本。如果你担心测试版本的系统可能会有不稳定的情况，可以等到今年秋季更新这些系统的正式版本。 Mac Pro 和 Pro Display XDR 2017 年 曾有消息 传出苹果正在重新设计 Mac Pro。时隔两年，苹果终于在本次 WWDC 上正式推出了这款全新的 Mac Pro。 新款 Mac Pro 回归了经典的塔式机箱外形，整个结构采用模块化设计。侧边则采用了类似「擦丝器」的镂空设计，底部可选配 4 个方便移动用的轮子，设计语言与上一代大相径庭。 苹果称这个设计主要是为了新款 Mac Pro 强大的配置而服务，事实也的确如此。新款 Mac Pro 最高可选配 28 核的英特尔至强处理器和 1.5TB DDR4 ECC 的内存。它同时配有 8 个 PCIe 接口，其中 4 个提供 double-wide 设计以适应更大的拓展卡。 为了提供充足的视频性能，苹果还专门为新款 Mac Pro 设计了一个名为 MPX 的拓展模块，它可以为两块显卡提供高速连接。新款 Mac Pro 可最高选配 2 个带有 2 块 AMD Radeon Pro Vega 2 显卡的 MPX 模块，这意味着它能够提供高达 128GB 的 HBM2 高速显存。 不仅如此，新款 Mac Pro 还配有一个专门的硬件加速卡，用于处理 4K 甚至是 8K 视频的渲染和转码，每秒可处理 63 亿像素的数据，满足专业人士对于剪辑 ProRes Raw 素材的需求。 接口方面，新款 Mac Pro 则提供了 4 个雷雳 3 接口，2 个 USB-A 接口 和 2 个 10Gb 以太网接口。 新款 Mac Pro 起售价 5999 美元，配有 32GB 内存、8 核心至强处理器、Radeon Pro 580X 显卡以及 256GB SSD 硬盘。今年秋季正式发售。 此外，苹果还推出了 Pro Display XDR 专业级显示器。它拥有一块 32 寸的 IPS LCD 屏幕，分辨率为 6016x3384，苹果称其为 Retina 6K Display。这款显示器在对比度方面达到了 1,000,000:1 的标准，亮度为 1000 nits，峰值亮度可达 1600 nits，苹果表示它在 HDR 上表现非常出色，超过了一般的行业标准，因此他们把它称为 Extreme Dynamic Range，简称「XDR」。 为了提供更出色的显示体验，苹果还为 Pro Display XDR 设计了一个多角度可调的桌面支架，支持竖屏模式显示。另外 Pro Display XDR 还可选配带有 Nano-texture 处理的屏幕，可在保证屏幕显示效果的同时降低屏幕的反射率。 Pro Display XDR 售价为 4999 美元，带有 Nano-texture 屏幕的版本售价为 5999 美元，桌面支架需单独购买，售价 999 美元，今年秋季正式发售。 ","link":"https://hesy-zhoulijie.github.io/post/wwdc19/"},{"title":"Mac 电脑终极选购指南","content":"Mac 电脑终极选购指南 我自己是从 2012 年开始使用 Mac 的，而且基本上经历过了 MacBook、MacBook Air、MacBook Pro、iMac、iMac Pro，应该可以说非常了解了。其实我在今年年初写过一篇文章，系统地介绍过 Mac 的购买和使用，目前仅在知乎就有超过 8000 的点赞和 100 万的阅读量。但是今年苹果对于 Mac 的更新节奏特别快，几乎多数的产品线都有或多或少的更新，所以当时那篇文章现在已经完全不适用了。 所以，也就有了今天这一篇。 在这篇文章中，还是主要回答两个问题： Mac 是不是适合你？ Mac 哪一款适合你？ Mac 是不是适合你？ 在很长一段时间里，拥有一台苹果电脑来说是一件很「装逼」的事情。在星巴克，抿一口拿铁，打开 MacBook Air，当信仰标志亮起的一刻，仿佛自己就是世界的焦点。所以每当我们提到苹果电脑的时候，大家的第一印象一定是「装逼」和「贵」。 再好的工具，也一定有适用人群，所以为了节约大家的时间，如果你是我说的以下几种人，就没必要往后阅读了： 游戏爱好者。想要在电脑上打游戏，任何门类的游戏，无论是主机游戏，还是网络游戏，Mac 电脑都不适合。 专业软件不支持 macOS 。这个因为情况较多，需要你自行了解。一般来说，你可以向同事了解，公司是不是有仅在 Windows 上才能运行的专业软件。如果是学生，就向学长学姐了解一下你的专业是不是有无可代替的软件一定要在 Windows 上运行。目前已知的是，像一些金融或者是财会类的软件在 Mac 上要么无法运行，要么就是像 Excel 这种软件，在 Mac 上运行功能会有阉割，例如 CAD 虽然可以用，但是表现不好。 预算不够。目前来看，如果你买电脑的预算不是 8000 以上，就请不要考虑 Mac。因为，无论怎么说， Mac 依然属于昂贵的电脑。 那么你选择 Mac 的理由是什么呢？ 系统的稳定 我先提前打预防针，我知道一定会有人评论稳定性已经不如从前了等等，但不得不承认，今天 macOS 的稳定性依然是远超 Windows。尤其是对一些女孩子来说，macOS 省心省力。macOS 因为特殊机制，避免了普通用户乱下载软件，或不小心下载流氓软件，甚至是中毒的风险。 系统的流畅度 这也是 Mac 的核心优势之一。这种流畅度也很好理解，你如果使用过 iPhone 和安卓机，就会发现配置再好的安卓机感觉上还是不如 iPhone 流畅，这个结论在 Mac 上也是成立的。 创意工作的沉浸体验 为什么几乎所有的摄影师和音乐创作者都会选择 Mac 电脑，就是因为整个系统的沉浸体验极佳。所有的创意工作都非常在意所谓的「灵感」，Mac 系统可以让你全身心投入，不会有「广告弹窗」打扰你，尤其是像是 Photoshop 和 Lightroom 这种软件，在 Mac 上运行行云流水。除非你的配置太老，基本上 Photoshop 都是秒开，这一点对创作全靠心情的摄影师很重要。 而对视频剪辑来说，Final Cut Pro 这款软件仅仅只能在 Mac 上使用，所以很多喜欢这款软件的用户也会优先选择 Mac。而如果你选择了 Mac，请你一定要学会使用它，因为它是最容易上手且专业的视频剪软件。 优秀的屏幕及影音体验 Mac 的这一块 Retina 屏幕绝对是目前笔记本行业里的标杆。你要记住的是，虽然参数上不是极致的，例如现在的笔记本动不动就是 4K 分辨率，但是得益于苹果的软硬结合，尤其是在字体渲染等方面 macOS 有着自己独特的优势，在实际观感上绝对是上乘，而 Windows 电脑对于高分辨率的支持实在是落后更加明显。 说到音响，Mac 更是有着绝对顶级的表现，尤其是 MacBook Pro 的音响，可以用「震撼」这个词来形容。 优秀的外观和工业设计 我相信，这是很多女孩子种草 Mac 最重要的原因之一。Mac 电脑的设计都是需要经过长时间的考验，这也就意味着，你选择的是一个经久不衰的外形设计。例如，即使这一次在更新 MacBook Pro 的时候，外形并没有改变，它依然颜值出众。 苹果生态的紧密结合 如果你除了 Mac 以外还使用其他苹果产品，那么你会感受到苹果生态的魅力。最简单的，如果你使用 iPhone 可以无缝使用隔空投送传递文件。而如果你现在有 iPad，甚至是可以使用随航功能，你的 iPad 可以成为 Mac 的第二块屏幕，甚至是数位板。 对了，这里有一点非常重要的声明，就是说 Mac 是有 Office 的，这也是大多数人误会最多的地方。Mac 上的 Office 套件可以正常使用，只不过会有一些专业功能的阉割，尤其是在 Excel 上，当然，如果你不是重度用户就不需要担心。一个小番外，其实 Office 本来就是乔布斯邀请盖茨做的，这个故事非常有意思，有机会再分享给大家。 但是，我一定要再强调一次，上述所说的所有一切都是建立在你使用 macOS 的基础上，如果你买回来就装了一个 Windows，那以上的优势几乎没有。 如果你看到这里，决定要购买 MacBook（Pro），那么接下来你可以继续思考之前我说的两个问题，它们决定着你能不能买到真正适合自己的 Mac。 问题一：你的预算是多少？ 这非常关键，只有在搞清楚这个问题以后，我们后面才会有讨论的必要。在你做出预算的时候，需要清楚一件事： 「Mac 是昂贵的电脑，但也是有着高性价比的电脑」 这个说法看起来是矛盾的，但我们可以简单地做这样一个计算：目前，苹果官网最便宜的 Mac 是 MacBook Air，售价是 8899。什么概念？这个价格可以买到市面上绝大多数品牌电脑的高配版本，而你在 Apple 这里却只能买一个「只能打打字，看看剧」的上网本（当然了，这可能是最好看的上网本）。 所以，Mac 贵吗？当然贵。 那么高性价比从何而来呢？ 我上一个笔记本电脑是 MacBook Pro 2012 款，这款电脑我一直用了 5 年，最后换掉的原因并不是因为卡顿，只不过是因为我剪辑视频要上 4K，实在是难为一款 5 年前的电脑。也就是说，任何一款 Mac 的寿命一定是三年以上，而且三年以上运行依然流畅，4-5 年才会感受到电脑配置不够用。 对于很多仅仅是当作上网本的用户，轻轻松松用个 4-5 年没问题，但是对于任何一款 Windows 笔记本，别说 3 年以上，2 年不到绝对就会变成开机等一分钟的状态（绝大多数的使用者）。 如果是对于缺乏电脑常识的用户，用不了多久电脑就会变成各种流氓软件全家桶，所以，不夸张地说，Mac 的使用寿命是 Win 的两倍。 因此，只要是适合的人，Mac 的确是有性价比的，甚至是像 iMac 5K 这样的产品更是极具「性价比」。 好，说了这么多，现在你可以想想到底可以拿出多少钱来购买 Mac 。 这个数字一定是你的最高预算。 问题二：你的需求是什么？ 这是一个比价格还要难回答的问题，很多人对自己的需求并不是很确定，但是你一定要有一个轻重缓急的排序，例如你是更加看重颜值、重量，还是性能和屏幕尺寸。 假设，我们的电脑是用来修图学摄影，那么屏幕尺寸和性能就是需要优先考虑的要素，便携性就需要让步。需要记住的是，没有完美的电脑，比如便携性和性能同时达到完美是不可能的。而且，并不是纸面上的参数性能越好就越适合你，其实对于绝大多数人来说，Mac 的性能都是过剩的。 在有了以上的准备工作以后，我们现在终于可以走进 Mac 的世界。 哪一款 Mac 适合你 目前的 Mac 电脑已经横跨了各个用户群体，从普通到专业。在本文中，因为需要考虑更多的受众，所以非常专业的 Mac 例如 iMac Pro、Mac Pro、Pro XDR Display 这些设备将不会涉及。而且我也相信这些用户本身应该比我更了解 Mac，所以接下来，我会把目前官网在售的 Mac 分为六个型号： MacBook Air 目前所有的在售笔记本中，MacBook Air 是性能最弱的一个，不过相应的也是价格最低的一款，官网售价是 8899 起步。 这是一款标准的上网本，优点有： 强续航。因为不需要很强的性能，所以能耗控制得很好，这也是目前在售的笔记本中续航最好的一款，基本上充一次电就可以满足一天使用，可以说摆脱了充电线的困扰，带到哪里都不需要找充电插座。 高颜值。颜值对于很多用户来说都是非常重要的指标，尤其是对于女性用户。MacBook Air 经典的楔形设计，尤其是玫瑰金色，可以很好地搭配衣服和包包，颜值出众。 轻机身。这里的轻，并不是机身轻，而是考虑到携带充电器以后的整体重量。 它的缺点有： 性能不够强劲。但是正如一开始所说，性能是因人而异的。换句话说，性能是相对的。如果你平时就是看看剧，写写文档，处理一些工作任务绰绰有余。哪怕是适度的照片处理也是没问题，4000 万像素的 Raw 格式也带得动，但是剪辑一个 4K 影片肯定是不行的。 屏幕色彩素质相对较低。在目前的 Mac 型号中，MacBook Air 仅仅覆盖了100% sRGB，而其它都已经是标准的 P3 广色域，所以如果你从事的职业对于色彩有要求，那么就需要谨慎。不过如果不是专业用户，那么这块屏幕的细腻程度和实际播放效果还是很好。 两个 USB-C 接口。由于目前 Mac 系列的笔记本都已经采用了 USB-C 接口，所以想要连接一些外设可能需要转接设备，但是因为 MacBook Air 只有两个接口，可能会出现接口不够的情况。当然，如果你的工作几乎不需要任何外设，那么也就不需要担心这个问题。 在具体的配置选择上，建议硬盘一定要选择 256GB 以上，千万不要因为价格选择 128GB。128GB 将会大大缩短 Mac 的使用寿命。身边已经有越来多的案例证明，最后更换 Mac 的原因基本上都是因为硬盘存储不足。 总体来看，MacBook Air 适合对于性能没有需求，但对颜值和续航有需求的用户。 相对来说合理的配置： 1.6GHz 双核第八代 Intel Corei5 处理器 8GB 2133MHz LPDDR3 256GB 固态硬盘（以上最好） MacBook Pro 13寸 （2 个雷雳 3 接口） 这是今年推出的新款 13 寸 MacBook Pro。在很多人看来，这其实是原本 MacBook Pro 13寸（4 个雷雳 3 接口）的阉割版本。的确，相较于下面将会介绍的 MacBook Pro 13 寸（4 个雷雳 3 接口）版本，这个版本降低了主频，同时砍掉了 2 个雷雳 3 接口，麦克风音质也有缩水。 但，这让他的价格仅仅只有 9999 元起，和 MacBook Pro 13 寸（4 个雷雳 3 接口）版本的价格差距为 2400 元（相同硬盘容量），并且一个重要信息是： 虽然二者的主频分别是 1.4Ghz 和 2.4GHz，但是二者性能基本相当。跑分结果来看，只是微弱的差距，所以 MacBook Pro 13 寸（4 个雷雳 3 接口） 能处理的任务， MacBook Pro 13 寸（2 个雷雳 3 接口）也一样可以胜任。 那么基本上，2400 元的差价让 MacBook Pro 13 寸（2 个雷雳 3 接口）很值得购买。 所以总结起来，优点是： 极高的性价比。如果你想要用 Mac 处理照片、视频、文档，并且预算吃紧，那么这一款就是最好的选择。 兼顾尺寸和性能。13 寸的笔记本，一直都是市面上比较常见的尺寸类别，重量适中，屏幕适中，移动便携。 缺点： 音响质量在所有 MacBook Pro 中稍逊一筹。 缺少两个雷雳 3 接口。这是我认为 MacBook Pro 13 寸（2 个雷雳 3 接口）最大的问题。因为既然购买了 Pro款，一定是对内容生产有要求的，那么必定需要很多外接设备，所以如果只有两个接口，就需要考虑使用扩展坞来解决这个问题。 购买建议是，切记不要购买 128GB 版本，一定要购买 256GB 版本。不然刚开机，装一些大型软件，例如Photoshop 或者是 Final Cut Pro X之类的就已经满了。 我知道因为价格很相似，很多购买 MacBook Air 的人可能会说，那么我为什么不加一点点钱购买这一款。这种想法很有道理，MacBook Pro 13 寸的屏幕和性能都会好很多，还有 Touch Bar。但还是那句话，你要想清楚自己看重的是什么。如果自己本身对于性能没有要求，只是追求便携、续航和颜值，MacBook Air 依然具有优势。 相对来说合理的配置： 1.4GHz 四核第八代 Intel Core i5 处理器 8GB 2133MHz LPDDR3 内存 512GB 固态硬盘 MacBook Pro 13 寸（4 个雷雳 3 接口） 优势前面其实已经讲过了，那么如果你确定要购买一款 13 寸的 Mac，那么肯定是在两个接口和四个接口之间选择一个，所以这款电脑的优缺点也就明显了，优点是： 四个接口，基本上可以满足各种外设接口，尤其是想要使用 13 寸 Mac 连接显示器的用户更是需要注意，如果你购买两个接口的版本，就意味着显示器和电源以后就再也没有接口连接，所以最好选择这个版本。 音响音质更好。 缺点是相对两个接口版本，价格较贵，要 13899 元起步。 最推荐的配置是： 2.4GHz 四核处理器 8GB 2133MHz LPDDR3 内存 512GB 固态硬盘 Macbook Pro 15寸 如果你是一个视觉或者音乐相关的专业用户，那么 15 寸的 MacBook Pro 就不用说了，应该是身边的人都在用。我几乎身边所有的摄影师朋友或者是搞音乐的朋友基本都是一水的 MacBook Pro 15寸。 优点： 更大的屏幕尺寸就意味着更高的效率，尤其是对于视觉用户来说，15 寸和 13 寸的修图感受完全不一样。 更强劲的性能。目前 MacBook Pro 15 寸最低六核 i7，最高可以选择 8 核，是 Mac 性能的代表。如果你想要一台性能最好的 Mac，那么就是这一台。更重要的是，15 寸的 Mac 是标配独立显卡，这在一些图形渲染的工作上和 13 寸有着本质区别。 更大的触控板。 缺点有： 相对 13 寸不够便携。 起步价格 18199 元，一般用户难以接受。不过对于专业用户来说，我相信因为是生产力工具，基本上价格就不成问题了。 我自己就是 15 寸 Mac 的重度用户，基本上无论是重度的图片修饰，还是影片的 4K 剪辑都可以流畅并高效的完成。目前来说，这也是很多创意用户选择最多的一个类别。 在配置的选择上，虽然 MacBook Pro 15 寸起步就是 256GB，但是对于是生产力级别的机器肯定是不够的，至少是 512GB 起步。我自己是 2T 硬盘，即使如此，同时剪辑 2、3 个视频的时候都有可能捉襟见肘。当然，也可能是因为视频大的原因。而且要注意的是，可能很多人希望通过外挂硬盘来解决，但是对于用来干活的机器，外挂还是会有很多不方便的地方。 所以既然已经花了这么多钱，就不要因为一两千块让自己使用得很不爽。在配置上，虽然我自己是把处理器升级到了 i9，但是并不建议大家这么做。处理速度会快一点，但是不明显，所以我的建议是有预算先升级硬盘、然后内存、然后是显卡。 相对合理的配置： 2.3GHz 八核第九代 Intel Core i9 处理器 16GB 2400MHz DDR4 内存 Radeon Pro 560X 图形处理器，配备 4GB GDDR5 显存 512GB 固态硬盘 iMac 5K 要说在所有的 Mac 中，哪一台最有性价比，那肯定是「买电脑送显示器」的 iMac 5K。你应该经常在各种公司前台看过这台机器，毕竟背部的颜值好。当然，更常见的应该是各种设计公司、摄影公司等等。iMac 5K 本身是一台以「27 寸」大屏幕为卖点的显示设备，它拥有一块： 「分辨率高达 5K ，覆盖 P3 广色域的」专业屏幕。 市面上类似素质的显示器都要上万元，而这台 iMac 5K 的起步价仅有 13832 元，还自带苹果不算便宜的键鼠套装。某种意义上来说，电脑相当于「白送」，所以这也是为什么很多商业机构会使用这款机器的原因。 优点： 拥有一块震撼的 27 寸 5K 显示器。只要你的工作是和视觉相关的，那么这块显示器都可以满足你的要求，无论是影片剪辑还是摄影后期都是利器，绝对是跟普通笔记本完全不一样的体验。 性能够用。因为是台式机，在散热等方面有优势，并且都是桌面处理器，所以一般来说会比相同价位的笔记本性能要好一点。 缺点： 台式机，几乎不具备任何移动性，并且一定要连接电源才可以使用，所以适合固定地点办公。 粗边框。相对于目前的主流屏幕设计，iMac 的设计相对老旧，粗边框一直都饱受诟病。 如果你想要购买 iMac，尽量不要因为省钱而选择 iMac 4K，而是一定要购买 iMac 5K。因为 iMac 4K 的屏幕只有 21.5 英寸，效果大打折扣，并且显得边框更加「粗犷」。当然，还有一条重要的原则： 不要买所谓的融合硬盘，最好是固态硬盘。 其实一台电脑是不是卡顿，很多时候影响因素是硬盘速度，所谓的融合硬盘是少量的固态硬盘和机械硬盘的组合，所以会极大地影响机器的运行速度，尤其是在后期的时候。记住，不要看融合硬盘容量更大就选择，一定要以固态硬盘为主，256GB 可以，512GB 以上最好。 并且对于内存来说， iMac 并不是主要的升级对象，因为 iMac 5K 是支持自行更换内存条的，所以自己购买内存条再添加，可以把更多费用花在硬盘上。而且更换方式非常简单，女孩子只要是简单看一下教程都可以学会。 我自己家里就有一台 iMac 5K 已经服役很多年了，只要是后期修图和重度的影片剪辑基本上都是靠它，绝对是纯正的生产力工具。所以我还是很建议，如果是预算不足，而且真的没有那么需要移动的用户可以先考虑的是 iMac 5K，而不是 Mac 笔记本系列。 Mac mini Mac mini 在所有的苹果电脑里可能是最不为大众所知的产品，这是一条本来已经沉睡了很多年的产品线，突然在去年十月复活了。简单来说，Mac mini 就是一个体积很小的电脑主机，没有任何显示设备，需要你自行连接显示器使用，所以 Mac mini 的价格也相对较低，起步价只有 6331。 但是自行配备显示器这件事，还是很有门槛的，所以对于大多数人来说，我还是建议直接去买 iMac 5K，Mac mini 更适合程序员作为开发工具，而且一般来说这些人群本身也是自带显示器的。 尾声 好了，以上就是我对于目前 Mac 产品线的一个简单梳理。购买一台 Mac 就是像选择一个好伙伴，我们一定要想好预算和需求，不要购买到错位的产品。 目前， Mac 的产品线已经相对来说比较完整，购买渠道也很多，如果你认为官网或者是官方零售店的价格相对来说难以接受，那么大型电商的自营平台也是可以考虑的，价格相对来说可以有一部分优惠。淘宝，尤其是低价淘宝就要警惕了，羊毛终究出在羊身上，翻新做假已经是一条成熟的产业链了。 而如果是学生，是有教育优惠一说的，每年特定时间都是有折扣送耳机，但是今年已经结束了，时间一般都是 8-10 月份这一段时间。对了，最后我还是想要特别说一下： 不要因为自己的预算不够就购买低价的 Mac，Mac 电脑的价格并不是和性能成正比，如果你是一个对性能有需求的用户，预算不足就还请果断放弃，毕竟不能花了钱不解决问题。 还有，如果买了 Mac 就千万别装 Windows，那是在把你的钱打水漂。 作者 | @Derrick Zhang ","link":"https://hesy-zhoulijie.github.io/post/macbook/"},{"title":"测试版群聊语音/视频上线，macOS 版微信终于不那么残缺了","content":"测试版群聊语音/视频上线，macOS 版微信终于不那么残缺了 微信在 macOS 上的更新进度一直落后于 Windows，其实我已经习以为常了，甚至我开始用 Windows 版微信过于臃肿这样来安慰自己，但知道疫情期间两个月的远程办公，才让我感受到「落后」的悲哀。 没有微信群语音的两个月 尽管公司里已经普遍采用了钉钉作为办公服务软件，但基本只是作为日常人事管理系统使用，绝大部分人沟通还是通过微信。 原本定期的周会，远程办公期间改成了每日上午汇报工作计划，晚间汇报工作完成度，再加上不定期的项目沟通会，我觉得已经非常能折腾了，但使用 Macbook Pro 作为工作机，微信群聊不支持语音才是最让我崩溃的。 每一次群聊会议，都需要从电脑切换到手机上，想要发起群聊还只能从手机上发起；像我习惯带上蓝牙耳机沟通，也不影响家人……你应该能体会那种体验上的巨大割裂感。 废话了这么多，我只是想单纯的表达今天收到 macOS 版微信更新提示的激动，虽然还是 beta 版本，正式版连小程序都没上，估计还有的等。 除了新增群聊语音和视频之外，这版本也加入了新的消息引用样式，样式上类似 Windows/Android 版本，后面会具体演示；其次还有语音自动转文字，这两点也都是近期 Windows 版本微信更新的新特性。 期待已久：微信群聊语音 其实我一直也不大明白，群聊语音或视频功能应该是这类聊天软件核心功能之一，为何微信到现在才开放给 macOS 用户公测。但既然已经来了，那还是只能「真香」了。 唯一没能体验过微信群聊语音的估计现在只有 macOS 用户和网页版用户了吧，群语音/视频人数上限依然是 9 人，大概是觉得九宫格比较好看吧……毕竟微信也没有定义过多人会议场景，尤其是在推出腾讯会议之后。 消息引用样式变更，支持图片 原本微信消息引用在 macOS 上会用得较多，而微信在其他客户端全面优化消息引用样式之后，反而 macOS 端消息引用有点过于简陋。 新版本的消息引用已经修改成跟 Windows、Android 等客户端版本一样的形式，具备比较高的辨识度。 查看引用的文本消息，点击之后会以弹出的消息气泡形式展开，会比手机上全屏展示体验更好。 当然，虽然来的晚，但也是直接支持了图片消息的引用。此外，经测试，语音消息暂时不支持。 语音自动转文字 虽然不支持引用，但也加入了最近在 Windows 版本新增的语音消息自动转文字功能。 对于上班族而言，一天到晚都带着耳机的毕竟是少数，语音消息拿起手机听的话，需要从工作状态中抽离出来解锁手机，而且声音没控制好，指不定女朋友发来什么消息（此处省略几百字……） 语音转文字默认关闭，需要手动在设置中开启。 收到语音消息后会自动转成语音，这点在工作期间还是比较实用的，尤其是经常有人喜欢发大段语音时，戴耳机听也会麻烦，手动转效率不够。 小结 自从有了小程序支持之后，我就基本在 macOS 上使用 beta 版本的微信，目前来看稳定性还不错，没有出现比较大概率的崩溃或者其他难以忍受的问题，而且正式版本已经许久没有新增功能，好歹 beta 版本在功能上是在追赶 Windows 端的，如果对群聊语音或者视频有迫切需求的用户，可以暂时切换到 beta 版本使用。 macOS微信beta版下载： https://dldir1.qq.com/weixin/mac/WeChatMac_Beta.dmg ","link":"https://hesy-zhoulijie.github.io/post/wechat-mac/"},{"title":"并查集","content":"并查集 洛谷der链接 题面 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 N,MN,MN,M ,表示共有 NNN 个元素和 MMM 个操作。 接下来 MMM 行，每行包含三个整数 Zi,Xi,YiZ_i,X_i,Y_iZi​,Xi​,Yi​。 当 Zi=1Z_i=1Zi​=1 时，将 XiX_iXi​​ 与 YiY_iYi​​ 所在的集合合并。 当 Zi=2Z_i=2Zi​=2 时，输出 XiX_iXi​​ 与 YiY_iYi​​ 是否在同一集合内，是的输出 YYY ；否则输出 NNN。 输出格式 对于每一个 Zi=2Z_i=2Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 YYY 或者 NNN 。 讲解 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。 (摘自百度) 关于并查集和路径压缩： 现在我们假定 f[i]f[i]f[i] 表示第 iii 个人的老大是谁。 现在我们有甲，乙，丙三个人（分别用 a,b,ca, b, ca,b,c 表示） 假设甲和乙打架了，甲做了丙的小弟。则有 f[a]=bf[a]=bf[a]=b， 后来甲打赢了丙 那么丙就是甲的小弟了。有 f[c]=af[c]=af[c]=a， 但是如果我们这样表示，丙不能直接知道甲，容易自己人打自己人 所以，我们必须直接让丙的大哥变成最大的老大。 定义函数 findfindfind int find(int k){ if(f[k]==k)return k; return find(f[k]); }//find 函数可以直接找到最大的老大 f[c]=find(a); //丙的老大是甲 这时，因为我们要路过他所有的上级，我们也可以顺便使途中经过的人的大哥也变成老大。 //路径压缩 int find(int k){ if(f[k]==k)return k; return f[k]=find(f[k]); /* 即： f[k]=find(f[k]); return f[k]; */ } f[c]=find(a); 简直是太巧妙了！ 而判定两个人的老大是否相等，只需 if(find(a)==find(b)) 就好了。 一些设定： 一个人不能有两个老大。 当已经有老大的人臣服时，老大也将成为胜利的人的小弟。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int i,j,k,n,m,s,ans,f[10010],p1,p2,p3; //f[i]表示i的集合名 int find(int k){ //路径压缩 if(f[k]==k)return k; return f[k]=find(f[k]); } int main() { cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) f[i]=i;//初始化i的老大为自己 for(i=1;i&lt;=m;i++){ cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3; if(p1==1) f[find(p2)]=find(p3); //p3打赢了p2 else if(find(p2)==find(p3)) //是否是一伙的 printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } return 0; } ","link":"https://hesy-zhoulijie.github.io/post/i_bBwEjyO/"},{"title":" 最全的PDF解决方案","content":"最全的PDF解决方案 Office转PDF 所有的Office2010+ 都具有“导出为PDF”的选项。甚至可以直接另存为PDF！当然你也可以在打印选项中选择Microsoft Printer to PDF PDF 阅读器 Windows 在Windows上的PDF阅读器多种多样，而且全平台的浏览器都可以打开PDF。 ① Adobe Acrobat Reader 相信不少人电脑里都安装了Adobe Acrobat Reader，这是目前使用最广泛的PDF阅读器之一。不过Adobe Acrobat Reader也有缺点，文档打开速度稍慢，只有弹出式注释工具，需鼠标点击方能阅读注释且无法修改注释文字格式。 综合结论：⭐️⭐️⭐️⭐️ 下载地址 ② Sumatra PDF 也是一款好用的PDF阅读软件，体积很小，打开文档速度十分快捷。Sumatra PDF最大优点在于支持搜索PDF文档内容，查找起来十分方便。但标注功能也略有限制。 综合结论：⭐️⭐️ 下载地址 ③ Drawboard PDF 记得时Surface自带的PDF阅读器，Windows应用商城里可下载。Drawboard PDF大概是最好的标注工具了，搭配Surface Pen一起非常好用。官方版请在Microsoft Store中下载。 PJB下载地址 ④ PDF-XChange Viewer PDF-XChange Viewer的文字渲染效果较差，不过它最大优势在于标注特别方便，可任意增减书签，也可以将PDF内容按章节划分标注。 下载地址 Mac 平时也会使用Mac，始终觉得Mac内置的阅读功能太简洁，标注功能严重缺失。 基本没有标注功能，也无法记录阅读进度。 所以Mac里推荐大家使用：Skim Skim也是一款很小的PDF阅读器，但功能却足够强大，标注/阅读/记录一应俱全。 手机 ①Acrobat Reader 安卓 ①PDFelement PDFelemnet更多的是标注、编辑功能，手机上快速处理一些PDF任务还是不错。 安卓 转换格式 All =&gt; PDF 打印 凹凸凹在线转换（还支持200多种除了PDF以外的文件） PDF =&gt; All ilovepdf smallpdf 这次就到这里啦！不足之处也欢迎大家补充指正。 希望有助，顺颂时祺。 ","link":"https://hesy-zhoulijie.github.io/post/pdf/"},{"title":"WPS2019完全体验指南","content":"WPS2019完全体验指南 — —对不起，我再也不黑WPS了 我们对WPS，有太多刻板印象 用惯了Office的用户（包括我），在谈到WPS的评价可能是到这几个评价。 “WPS没有布尔运算，做不了很多特定的形状。” “WPS太多广告了，不实用。” “WPS很多操作难找，不如office人性化。” “WPS是盗版office吧？？” 其实这些评价，也是大部分人对WPS产生的刻板印象，其实WPS的历史十分地悠久，各方面也一直在优化。 1988年一位叫求伯君的年轻人，在出租屋内敲下了一款文字处理系统——WPS，这也开创了中文字处理时代。 从这样 到这样 在1994年中国办公市场，WPS占据了90%，用户量超千万，要知道当时的微软，在1年前将Word和Excel集合在一起组成了Office。 人性化和部分功能缺失的问题，不可否认曾经的WPS确实做得很不好，以致于在一开始接触PPT的时候，我放弃在WPS操作，选择Office里的PPT。 就这样，我也和很多人一样，走上了一条逢人就说 “删WPS，用Office啦~” 的道路。 但是，上周下载并体验了最新版本的WPS2019后，我决定再也不黑WPS了。 WPS版人性化 相比起Office，在很多地方WPS确实不太合理，但是WPS也有自己闪光的部分，超级人性化的说，在这也做部分介绍，主要包括对齐、文档窗口折叠、字体预览、自带素材库、强大的外部链接。 对齐 在Office里，效率高的小伙伴设置对齐，会先把对齐按钮添加到快速访问工具栏，如果没有设置的话，你就需要手动找到横向分布和纵向分布。 在WPS里我们只需要选中我们需要处理的素材，我们会发现素材边缘会自动生成自动显示对齐框。 哇！ 标签页 在office里，我们时常会夸Excel、Word、PPT，甚至是思维导图，同时三四个文档“ Alt+Tab ”切换处理。 机智的程序员开发了office tab，支持同个文档类型的多开，但是依旧不支持跨文档类型处理，安装使用也是挺费事的。 但是在WPS（2016+），一个软件，全搞定。不得不承认，在颜值方面，WPS2019的界面真的还挺好看的，同时支持多款文档的窗口折叠，office三件套+思维导图+流程图。 字体预览 字体预览，一直是WPS不错的一点，选中文字后我们在选择字体处看到很多种字体预览，可以供我们下载，部分需要会员权限。 辣么多字体，看着就眼馋啊！ 外部软件关联 非常意外的是，WPS突破了原有传统office的三件套模式，串联了包括美化大师、思维导图，便签以及自带了一系列的文档处理转化工具，实现了文档处理一体化。 当然，WPS的部分模板是需要稻壳会员才可以免费试用，如果工作使用频率比较多的话，也可以选择充值，价格也不贵。 云 移动办公的时代，云盘和手机在文档储存与编辑上的作用越来越大，工作效率也越来越高，这部分真的很让我意外，当你下载了APP以后，会发现WPS还有很多很多的神奇操作，可以下载体验~。 手机编辑 我们都知道office不支持手机编辑，而wps则早已开发了一系列的手机端平台，包括手机端WPS支持App，公众号，小程序。 手机端的功能仍是琳琅满目 云存储 WPS的云储存，确实让我眼前一亮，实现了不同电脑、APP、微信公众号，小程序的同步云储存，意味着我们不再需要使用U盘各种复制，只需在电脑或者手机上使用同一个账号就找到WPS即可找到文档。 多端同步它不香吗？ 手机传图 手机传图也是一个很有趣的操作，只需要在WPS中插入选项卡，找到图片选项中的来自手机，扫描二维码以后在手机界面上传图片就可以完成了图片转移了。 手机遥控 只要在手机上安装了WPS，在PPT演示的时候我们可以找到投影宝，扫描电脑端的放映二维码即可实现连接。通过左右滑动可以控制页面播放顺序，在没有演示笔的时候可以考虑用手机遥控。 这里用一张官网上的图 线上会议 目前手机语音会议为免费使用功能，大家可以体验一番，不过WPS还是好多功能需充值~ AI in WPS 这里的AI是人工智能哦。 其他玩法 切换动画 新闻联播 在WPS里，发现了一个好玩的切换动态效果。 支持插件 曾经有人会说office高效是因为兼容得了很多得插件，其实这几年WPS也支持安装islide、Pa口袋动画、美化大师等多个插件。 总结 Office和WPS谁强谁弱，谁更好用的问题也是一直被人们讨论。 不得不否认，至今依旧有部分设计性功能是Office专有，而WPS无法比拟的，例如：布尔作品，3D玩法，更多样式的动画效果等。 尽管众多的PPT爱好者都崇尚Office，但是不得不否认WPS也有属于它的『办公』优势，也收获了众多粉丝。 ①基本满足了职场人士办公需求； ②体积小，官网下载不到100M； ③下载完全免费，无需购买序列号； ④安装方便，不会出现太多版本冲突问题； ⑤模板库，Ai生成等操作完全为现代人定制——懒人设计。 对工具的选择，取决于能否顺利解决我们的工作，至于使用office还是wps，大家可以根据自己需要选择。 我个人总结Office与WPS就是： 设计性，Office完胜；功能性，WPS够用。 分享完毕，希望有助~ ","link":"https://hesy-zhoulijie.github.io/post/wps/"},{"title":"让PPT变精致的秘密，都在这篇文章里","content":"让PPT变精致的秘密，都在这篇文章里 在PPT设计中，我们常常会使用到图标，用以修饰画面和辅助文字说明。作为PPT中的“增色剂”，图标能够让PPT更有视觉效果，因此也深受同学们的喜爱。 但是，PPT中的图标有千千万万， 为什么我们要掌握图标？ 图标的几种分类你都知道吗？ 我们怎么快速找到好看又合适的图标？ 是不是我们把图标插进去幻灯片页面就代表我们掌握了呢？ 下载下来的小图标怎么做能够更加生动有趣？ 带着这几个灵魂拷问，今天小醒目就来跟大家聊聊关于图标那些你不得不知道事儿。 图标到底有多重要呢？ 1.辅助文字说明 在演示设计中我们常听到一句话“字不如表，表不如图”，说的就是图的重要性。 图标作为“图”的一种表现形式，被我们广泛应用在PPT当中，在里面充当“指示内容”的作用。 其实不只是PPT设计，我们经常接触的APP界面，也是依靠图标提升用户对信息的感知度： 而在PPT中，图标通常伴随短文字一起出现，达到图与文的连贯理解效果，让观众一目了然同时图标也可以 2.提升幻灯片的画面感 图标除了能够辅助文字说明之外，它还能起到一个很重要的功能就是美化幻灯片。特别在幻灯片文字比较少的时候，图标就起到很好的补充画面的作用了。 比如： 同一个图标，不同的形态 还是上面的文字，可以化用不同的图标 可以添加背景 还可以用渐变色 真香。 在这里也只安利一个网站 阿里巴巴矢量图标库 http://www.iconfont.cn/ 这个网站是现在质量最高的图标库，里面的图标不仅数量庞大、风格统一，而且美观也能符合现在PPT设计的潮流，光这几点就可以帮我们省去很多筛选图标的时间了。 此外，阿里巴巴矢量图标库还提供无限量免费下载，这对于需要在幻灯片中插入大量图标的同学来说简直是福音！ 在下载选项中，这个图标库还很贴心提供了自选颜色，免得同学们因为难以更改颜色而放弃一个心仪的图标。 除此之外，阿里巴巴矢量图标库还提供现在主流的几种格式让大家下载，像最通用的PNG格式，以及下载后还能重新编辑的SVG/AI格式。 像SVG格式，如果同学们用的是Office365的话，可以直接拖进PPT中，右键取消组合两次就可以自由编辑了 图标的颜色也很重要哦！ 配色很大程度上决定了PPT长什么样子。使用阿里巴巴图标库的SVG格式导入的图标，取消组合后就可以愉快的编辑啦！ 自己调整完配色，就会很好看哒，比如说这两个 干巴巴的图标很难看，如果这样呢？…… 哇！好美！ 还有呢！ 这是针对深色线性或者填充图标使用的小技巧，这两种图标能给人带来简约的感觉，但看多了会觉得单调，这时候我们在图标加上一个小色块作为点缀，小图标瞬间就有点“活泼”的感觉： 再来讲一种优化的方法—长投影 先把图标备份一遍 然后放大到400%，Cmd+D（Ctrl+D）复制一个，把新复制的图标平移到原图标斜下方45°并且与原图标无限接近的位置。 无限摁Cmd+D（Ctrl+D）。觉得阴影长度适合就可以停止复制粘贴了，然后我们把这份投影初稿全选，点击选项卡**“格式”——合并形状——结合**，这样我们的长投影就做好了！ 想调整字体？ 也可以哒 首先插入文本框，随便敲一点东西。 把它用个举行盖住，全部选中。 把蓝色的矩形删掉 wohoo！ 不知道大家看到这里有没有对PPT中小小的图标有个新的认识，其实图标作为一个独立的设计元素，真的值得每个PPTer去重视的，而且图标也还有很多玩法有待挖掘，比如通过虚实大小去表现内容重要程度，或者和文案结合。 这期的分享就到这里了，希望对大家有所帮助，我们下期再见。 本篇的PPT素材请自行下载 让PPT变精致的秘密，都在这篇文章里-配套PPT.pptx 密码：uu62 ","link":"https://hesy-zhoulijie.github.io/post/icon/"},{"title":"微信是个好东西，但是你会用微信多少功能呢？","content":"微信是个好东西，但是你会用微信多少功能呢？ 消息换行 用过QQ电脑版的盆友都知道QQ电脑版的换行是Ctrl+⏎（⌘⏎），但是微信呢？如果你要尝试每一行发一条消息，然后这样做，相信我他会跟你绝交的！ 哼～～ 其实使用Shift+⏎（⇧⏎）就可以换行啦！ 而且Shift+⏎在大多数文字编辑软件中都能用滴！ 巧用“收藏” 首先强调一下，不论是在PC还是手机，收藏大小总共只有 2G2G2G！ 首先看看笔记 同时可以添加标签进行整理 更改设置 把自己几个G的文件别存在C盘了！ 聊天中的快捷方式 引用功能 截图工具 同步消息 经常在PC微信和手机微信间切换的伙伴一定深有感触，PC微信虽然方便，但有时候聊天记录无法同步，还是得掏出手机，来回切换十分影响效率。 其实微信是可以同步聊天记录的，只是不像QQ始终云端同步而已。 操作方法也非常简单：电脑端点击左下角，选择备份与同步。 这样就OK啦！ 设置自带表情包的昵称 相信大家平时在微信群聊的时候都遇到过这种情况，@某人时居然会有表情掉落！这个看似神奇的操作，其实并不复杂，设置起来非常简单，只需要在自己的昵称后面添加一些后缀就可以了。常见的有这些 么么哒： จุ๊บ 星星代码：ฉันคิดถึง 蛋糕：สุขสันต์วันเกิด 一些损人的技巧 //fullexit （发送出去）强制退出微信登录 :recover 搜索它，会跳出一个“微信修复工具” 就像这样（多平台适用） 这里还是有很多骚操作的！ ","link":"https://hesy-zhoulijie.github.io/post/wechat/"},{"title":"博客阅读指北","content":"点击这个“归档”查看所有文章 不要点进来。。。 ","link":"https://hesy-zhoulijie.github.io/post/PjSoP3sCF/"},{"title":"文件共享方法总结","content":"文件共享方法总结 写在前面 笔者家中有2台电脑，但是在两台电脑之间共享文件是一个很麻烦的事情，所以通过对Win10和Mac OS X 13的充分研究整理，完成了本份攻略 方法1 自带文件共享 效果： 这种方法在Windows上的实现方法： 然后到Mac上 但是IP地址在每台电脑上都不一样 所以我们就需要金坷垃ipconfig! 具体的IP取决于你用的网络连接种类，如果是以太网就看以太网的，WLAN就看WLAN的。 然后在Mac上点进去，输入用户名和密码，** 这里要输入的是密码，不是PIN！！！ ** 然后直接Ctrl+C，Ctrl+V进行复制粘帖就可以啦！！！ 方法2 远程登陆 首先在Mac的找到“请键入“ssh ***.***.***.***@******的东西” 然后到Powershell里面打开就可以了。 反过来，用方法一中的本地ip也可以 在Mac上用ssh登陆Windows ","link":"https://hesy-zhoulijie.github.io/post/file_share/"},{"title":"调整软件设置，让 PPT 更符合你的使用习惯","content":"调整软件设置，让 PPT 更符合你的使用习惯 幻灯片大小 幻灯片大小分成nnn种，可以自定义的哦。 我这里用的是Mac版本的Office365，Windows应该绝对差不多 从这里可以发现，各种大小都可以，所以建议大家按照需求进行自定义。 此外，如果你的 PPT 有其他需求，也可以选择「自定义幻灯片大小」。里面除了可以设置「信纸」、「A4 纸张」或「横幅」等特别的格式大小以外，也可以自定义幻灯片的宽度和高度，以及调整幻灯片或备注的方向（纵向、横向）等。 关键来了，有的时候你需要在编辑时调整大小，就会看到这个窗口 建议大家选择缩放。 字体 Office系列的默认字体是等线，但是这种字体实在是太丑了！ 我们可以通过万能的百度下载到无数的字体，但是PPT的时候还是需要一个个修改，让人苦不堪言。 有没有想Keynote的字体更改工具呢？那是当然。 在我的版本中，可以直接使用字体更改工具。 但是有人没有这个功能啊，怎么办呢？ 可以使用字体更改器，在设计里点“变体”，下面就有字体选项卡了。 在这里找到自己喜欢的字体。我比较喜欢这个 更重要的是，这里一旦更改完，你插入的所有字体都是这个！ 颜色 和字体差不多，在同一个地方还有“颜色”的选项卡，颜色同时可以自定义的哦。 比如说上面```Custom``就是我自定义的哦。 快速访问工具栏 很多人都抱怨过Powerpoint没有自定义的功能，其实是你不知道在哪里。 就是这里！！！（在最上面） 点开最右边的按钮 这里可以把自己喜欢的小功能添加在这里 当你添加的功能稍微多了点，就会发现窗口上方挤着一整列工具，且使用时还得将鼠标移到窗口上方，颇不方便。 此时，你可以拉开「快速访问工具栏」最右边的选单「自定义快速访问工具栏 - 在功能区下方显示」，就可以将这一列工具移到功能区的下方了。 备注：只支持Windows！！！ 在设置好「快速访问工具栏」之后，你可以在「其他命令 - 导入/导出」，把专属于你的「快速访问工具栏」导出自定义文件。 这可以让你在另一台计算机使用 PPT 时，能够直接导入文件，而不用再重新设置「快速访问工具栏」。 ","link":"https://hesy-zhoulijie.github.io/post/powerpoint-usage/"},{"title":"使用macOS Catalina的面板编辑器进行便捷控制","content":"使用macOS Catalina的面板编辑器进行便捷控制 面板编辑器入门 1. 什么是面板编辑器 面板编辑器是用来自定义面板（虚拟键盘）的。 路径： /System/Library/Input Me thods/Assistive Control.app/Contents/Resources/Panel Editor.app 重要！！！只有macOS Catalina有！！！ 重要！！！只有macOS Catalina有！！！ 重要！！！只有macOS Catalina有！！！ 2.如何使用 沿袭了Mac软件简单易懂的优良品质，可以直接用的哦！（是不是很香） 按左上角的添加面板就可以了。 因为面板不能直接链接到软件的菜单，只支持这些 于是我们需要先添加快捷键然后才能添加。 关于如何添加快捷键，请参考文章Mac如何自定义快捷键传送门 完成快捷键添加后，这里我以前往桌面来举例子 在操作中选中按下按键，输入快捷键⇧⌘D(Shift+Command+D) 点击保存，然后就可以用啦！哦，别忘了，记得选中在那些应用中有效（上面）哦 打开虚拟键盘后，点击左上角的设置按钮，在自定面板中找到你刚刚用的名字的选项，然后就大功告成啦！ 高级控制 可以通过macOS的辅助功能进行高级控制，比如启动进程，系统事件（下图）等等。 同时也支持打开App，运行Applescript等等，简单来说，啥都支持。 使用案例 这是我在使用腾讯课堂的时候用的面板 其他的功能会陆续更新 ","link":"https://hesy-zhoulijie.github.io/post/面板编辑器/"},{"title":"Mac如何自定义快捷键","content":"Mac如何自定义快捷键 写在前面 本页面使用sm.ms图床，网速比较慢，大约需要加载5秒，请稍后。 Mac上不像Windows有很方便的定义快捷键的工具，于是我们就需要通过系统偏好设置来自定义。 Mac如何自定义快捷键 写在前面 本页面使用sm.ms图床，网速比较慢，大约需要加载5秒，请稍后。 Mac上不像Windows有很方便的定义快捷键的工具，于是我们就需要通过系统偏好设置来自定义。 第一步：进入需要自定义的应用 这里举个例子，我要在Microsoft word里添加一个绘制横排文本框的快捷键：⌘+t 首先我在菜单中找到“文本框” 一定要记住他的名字！！！ 第二步：打开系统偏好设置 这样就OK了 来看看效果（关注左下角软键盘） 是不是很香！ ","link":"https://hesy-zhoulijie.github.io/post/mac-shortcut/"},{"title":" Keynote完全指南","content":"Keynote完全指南 如何用keynote做一个PPT 首先打开Keynote软件,会看到这样的界面. 点击新建文稿, 这模板多得可以啊. 我就随便选一个. 主界面和Microsoft Powerpoint差不多呢! 打开来:字体很漂亮,但是没法看啊(QaQ) 所以,第一步: 更改字体 这里可以把全PPT的主题字体修改成自己想要的 这样就好看多了吧 接下来看看有什么样的版式呢? 每个模板都有这些版式的哦 接下来就可以开始写了 突然发现,这里好像不能直接画图形诶??? 是的,每一次新建一个图形就会给你画出一个1:1的这个图形 如果插入了图像也不要紧 都可以完成编辑. 这里的编辑遮罩就相当于裁剪啦 Keynote也同样支持插入图表 而且很好看,最重要的就是他不需要打开另外的软件就可以编辑数据!!! 他不需要打开另外的软件就可以编辑数据!!! 他不需要打开另外的软件就可以编辑数据!!! 是不是很香? 如何添加动画??? Keynote的动画比Powerpoint的好一百倍! (进入动画) (强调动画) (退出动画) 哇! 太帅了!!! 每个效果都有不同的选项 举个例子🌰 香不香??? 各种动画都很酷炫 比如这个 总共只有一个动画,叫做神奇移动 我肯定没吭你 这里的坑很深,不是一天两天能讲清楚的. 大家可以在bilibili上搜索关于keynote动画的更详细内容 如何演示keynote 因为keynote所有专门的动画都必须要用.key文件才能放映,但是只有Mac有keynote,于是我们有三种方法进行分享 iCloud 将文件上传到iCloud,可以在网页端直接编辑,也可以远程下载或者放映 Keynote Live 支持在本地放映云端观看 然后就可以远程观看了,只不过观看端加载很慢 观看端是这样的 记得放映的时候要选择上面的那个选项哦 导出视频 在这里选择导出格式和时间控制然后直接打开视频文件就OK啦!!! 最后 PPT可以直接在Keynote里打开,替换字体就很香了. 其他的教程我会陆续发在这里. 百度上有很多的keynote模板,可以自行下载. ","link":"https://hesy-zhoulijie.github.io/post/keynote/"},{"title":" GitHub博客+gridea的搭建指南","content":"GitHub博客+gridea的搭建指南 系统环境 macOS Sierra+ Win7+ GitHub部分 首先注册GitHub账号 然后进入这个仓库 （这是我的仓库） 接着打开Grieda 先点远程，在这里输入自己的账户信息 然后直接点击新建就可以愉快的写作了 最后点发布，OK了！ ","link":"https://hesy-zhoulijie.github.io/post/Gridea/"},{"title":"高效使用Chrome浏览器，你可能不知道的10个技巧。","content":"高效使用Chrome浏览器，你可能不知道的10个技巧。 转载自 工具狂人 浏览器，是通向精彩网络世界的一个重要通道，基于此，它也占据了电脑的大部分使用时间。 为增强浏览器的功能，我们会为它安装各种插件，但其实除了从外部的插件入手，我们还可以通过掌握一些浏览器使用技巧，来提升其使用效率。因此，今天的这篇文章，我从使用浏览器可能会遇到的问题出发，整理了一些对应的解决方法，希望对你有帮助。 另存为PDF 以保存微信公众号文章为例，在浏览器中打开文章，右击页面，选择「打印」。在弹出的窗口中，将「目标打印机」更改为「另存为 PDF」。更改为另存为 PDF 后，下方的按钮会由「打印」自动更改为「保存」，点击保存，就可以 PDF 文件的格式保存网页内容。 网页存档 除了将网页保存为 PDF 文档，我们还可以将网页保存为它原本的格式「HTML」。在网页的空白处右击页面，选择「另存为」，保存格式可选择 mhtml 或 html，区别在于： 保存为 html 会额外生成一个文件夹，而 mhtml 会将所有元素保存在同一个文件中。 使用剪藏 为方便在不同设备间查看保存的网页内容，我最常使用的方法，还是将内容保存到笔记软件中。 对于电脑端的浏览器，将网页内容保存到笔记软件，需要先安装对应的浏览器插件，如印象笔记的「Clip to Evernote」或有道云笔记的「有道云笔记网页剪报」。 网页长截图(Chrome内核专用) 和使用手机一样，在电脑上浏览网页，有时也存在截取长图的需求。 除了为电脑安装第三方截图软件，其实我们还可以使用浏览器自带的功能，来获取长截图。 使用 F12 打开浏览器「开发者工具」，使用快捷键 Ctrl + Shift + P 打开命令面板，输入「full」，下方会返回「捕获全屏」的命令。 点击运行命令「Capture full size screenshot」，就可以得到当前网页的长截图。 解除禁止🈲️复制 有些网站出于保护内容的目的，如 B 站的部分专栏文章等，会将网站的内容设置为禁止复制。 除去侵犯他人权益的动机，有时我们复制一些内容，纯粹是出于学习或交流的目的。 对于禁止复制的内容，我们最常用的应对方法可能是截图，除此外，我们还可以使用两种方法来解除网站的禁止复制。 a) 关闭javascript 使用 F12打开浏览器「开发者工具」，点击开发者工具右上角的「 ⋮ 」按钮，选择「Settings」。在打开的页面中，找到 Debugger 下的「Disable JavaScript」选项，将其暂时勾选，禁用浏览器的脚本功能。此时，使用 F5 刷新当前网页，原本不支持复制的内容就可以随意复制了。 b) 复制HTML 复制 HTML 中的文本内容，仍然需要用到「开发者工具」，打开之后，点击左上角的「箭头」图标，切换到元素选择工具。 切换到选择工具后，将鼠标移动到你想复制的内容上方并单击，在右侧的开发者工具窗口，可以看到当前文本在 HTML 中的位置，双击文本内容，右键选择「复制」。 如此一来，通过这种方法，也能解除网页禁止复制的限制。 6. Chrome的实验性功能flags 首先声明，这里的 flags 并不是你年初立下的各种 flags，它指的是 Chrome 处于实验阶段的功能，大部分功能还未在正式发布的 Chrome 中启用。在 Chrome 地址栏中，输入 chrome://flags ，打开的页面就可以看到 Chrome 的所有实验性功能。这个页面不支持chrome自带的翻译,所以需要安装插件进行翻译哦 7. 网址前后缀添加 a) 下载油管video https://www.youtube.com/...=&gt; https://www.ssyoutube.com/... b) 下载B站视频 https://www.bilibili.com/...=&gt;https://www.ibilibili.com/... =&gt;https://www.bilibilijj.com/... c) 各种工具 https://*.*/...=&gt;https://wn.run/*.*/,,, eg. https://www.bilibili.com/* =&gt;https://wn.run/www.bilbili.com/* 写在最后 本文介绍的一些技巧，如解除网页禁止复制、下载网站视频，如果用于不正当用途，会存在侵犯他人权益的可能，建议使用时仅出于学习和交流的目的。 除了本文介绍的内容，你还知道浏览器的其他使用技巧吗？ 欢迎在留言区与大家分享。 以上，就是本次想和你分享的内容。 ","link":"https://hesy-zhoulijie.github.io/post/Chrome浏览器/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hesy-zhoulijie.github.io/post/hello-gridea/"}]}